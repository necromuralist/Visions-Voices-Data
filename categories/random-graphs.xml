<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Visions, Voices, Data (Posts about random graphs)</title><link>https://necromuralist.github.io/Visions-Voices-Data/</link><description></description><atom:link href="https://necromuralist.github.io/Visions-Voices-Data/categories/random-graphs.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents Â© 2019 &lt;a href="mailto:necromuralist@protonmail.com"&gt;Cloistered Monkey&lt;/a&gt; </copyright><lastBuildDate>Wed, 17 Apr 2019 02:22:39 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Looking at random graphs</title><link>https://necromuralist.github.io/Visions-Voices-Data/posts/networks/looking-at-random-graphs/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Visions-Voices-Data/posts/networks/looking-at-random-graphs/#org33dbd99"&gt;Imports&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Visions-Voices-Data/posts/networks/looking-at-random-graphs/#orgdff7cf6"&gt;Part 1 - Random Graph Identification&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Visions-Voices-Data/posts/networks/looking-at-random-graphs/#org643548a"&gt;Load the data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Visions-Voices-Data/posts/networks/looking-at-random-graphs/#org0f77442"&gt;Graph Identification&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Visions-Voices-Data/posts/networks/looking-at-random-graphs/#org3883dcc"&gt;Part 2 - Company Emails&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Visions-Voices-Data/posts/networks/looking-at-random-graphs/#org7e40ad3"&gt;Part 2A - Salary Prediction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Visions-Voices-Data/posts/networks/looking-at-random-graphs/#org759157e"&gt;Part 2B - New Connections Prediction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Visions-Voices-Data/posts/networks/looking-at-random-graphs/#org974d867"&gt;Separate the Target and Training Sets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Visions-Voices-Data/posts/networks/looking-at-random-graphs/#org61bd2bb"&gt;Scaling the Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Visions-Voices-Data/posts/networks/looking-at-random-graphs/#orgb71a6eb"&gt;Feature Selection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org33dbd99" class="outline-2"&gt;
&lt;h2 id="org33dbd99"&gt;Imports&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org33dbd99"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# python standard library
import os
import pickle

# from pypi
import networkx
import numpy
import pandas

from sklearn.linear_model import LogisticRegressionCV
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import (
    ExtraTreesClassifier,
    RandomForestClassifier,
    )
from sklearn.feature_selection import (
    RFECV,
    SelectFromModel,
)
from sklearn.model_selection import (
    GridSearchCV,
    StratifiedKFold,
    train_test_split,
    )
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;% matplotlib inline
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgdff7cf6" class="outline-2"&gt;
&lt;h2 id="orgdff7cf6"&gt;Part 1 - Random Graph Identification&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgdff7cf6"&gt;
&lt;p&gt;
For the first part of this assignment you will analyze randomly generated graphs and determine which algorithm created them.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org643548a" class="outline-3"&gt;
&lt;h3 id="org643548a"&gt;Load the data&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org643548a"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;part_one_graphs = pickle.load(open('A4_graphs','rb'))
print(len(part_one_graphs))
print(type(part_one_graphs[0]))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;code&gt;part_one_graphs&lt;/code&gt; is a list containing 5 networkx graphs. Each of these graphs were generated by one of three possible algorithms:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;Preferential Attachment (`'PA'`)&lt;/li&gt;
&lt;li&gt;Small World with low probability of rewiring (`'SW&lt;sub&gt;L&lt;/sub&gt;'`)&lt;/li&gt;
&lt;li&gt;Small World with high probability of rewiring (`'SW&lt;sub&gt;H&lt;/sub&gt;'`)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Analyze each of the 5 graphs and determine which of the three algorithms generated the graph.
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;The `graph&lt;sub&gt;identification&lt;/sub&gt;` function should return a list of length 5 where each element in the list is either `'PA'`, `'SW&lt;sub&gt;L&lt;/sub&gt;'`, or `'SW&lt;sub&gt;H&lt;/sub&gt;'`.&lt;/b&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0f77442" class="outline-3"&gt;
&lt;h3 id="org0f77442"&gt;Graph Identification&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org0f77442"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def graph_identification():
    """Identifies the type of graph each of the graphs is

    Returns:
     list: string identifiers for the type of graph
    """
    graph_types = []
    for graph in part_one_graphs:
	path = networkx.average_shortest_path_length(graph)
	coefficient = networkx.average_clustering(graph)
	if path &amp;gt; 6:
	    if coefficient &amp;lt; 0.5:
		graph_types.append("SW_L")
	    else:
		raise Exception("unexpected type")
	else:
	    if coefficient &amp;lt; 0.5:
		graph_types.append("PA")
	    else:
		graph_types.append("SW_H")
    return graph_types
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
This was marked wrong by the grader.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3883dcc" class="outline-2"&gt;
&lt;h2 id="org3883dcc"&gt;Part 2 - Company Emails&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org3883dcc"&gt;
&lt;p&gt;
For the second part of this assignment you will be working with a company's email network where each node corresponds to a person at the company, and each edge indicates that at least one email has been sent between two people.
&lt;/p&gt;

&lt;p&gt;
The network also contains the node attributes `Department` and `ManagementSalary`.
&lt;/p&gt;

&lt;p&gt;
`Department` indicates the department in the company which the person belongs to, and `ManagementSalary` indicates whether that person is receiving a managment position salary.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;email = networkx.read_gpickle('email_prediction.txt')
print(networkx.info(email))
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7e40ad3" class="outline-3"&gt;
&lt;h3 id="org7e40ad3"&gt;Part 2A - Salary Prediction&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org7e40ad3"&gt;
&lt;p&gt;
Using network `email`, identify the people in the network with missing values for the node attribute `ManagementSalary` and predict whether or not these individuals are receiving a managment position salary.
&lt;/p&gt;

&lt;p&gt;
To accomplish this, you will need to create a matrix of node features using networkx, train a sklearn classifier on nodes that have `ManagementSalary` data, and predict a probability of the node receiving a managment salary for nodes where `ManagementSalary` is missing.
&lt;/p&gt;

&lt;p&gt;
Your predictions will need to be given as the probability that the corresponding employee is receiving a managment position salary.
&lt;/p&gt;

&lt;p&gt;
The evaluation metric for this assignment is the Area Under the ROC Curve (AUC).
&lt;/p&gt;

&lt;p&gt;
Your grade will be based on the AUC score computed for your classifier. A model which with an AUC of 0.75 or higher will receive full points.
&lt;/p&gt;

&lt;p&gt;
Using your trained classifier, return a series of length 252 with the data being the probability of receiving managment salary, and the index being the node id.
&lt;/p&gt;

&lt;pre class="example"&gt;
1       1.0
2       0.0
5       0.8
8       1.0
    ...
996     0.7
1000    0.5
1001    0.0
Length: 252, dtype: float64
&lt;/pre&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge5159b4" class="outline-4"&gt;
&lt;h4 id="orge5159b4"&gt;The Data Frame&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orge5159b4"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if not os.path.isfile("email_data.h5"):
    data = pandas.DataFrame(index=email.nodes())
    data["department"] = pandas.Series(networkx.get_node_attributes(email, "Department"))
    data["management"] = pandas.Series(networkx.get_node_attributes(email, "ManagementSalary"))
    data["clustering"] = pandas.Series(networkx.clustering(email))
    data["degree"] = pandas.Series(email.degree())
    data["degree_centrality"] = pandas.Series(networkx.degree_centrality(email))
    data["closeness_centrality"] = pandas.Series(networkx.closeness_centrality(email))
    data["betweenness_centrality"] = pandas.Series(networkx.betweenness_centrality(email))
    data["pagerank"] = pandas.Series(networkx.pagerank(email))
    _, authority = networkx.hits(email)
    data["authority"] = pandas.Series(authority)
    data.to_hdf("email_data.h5","df" )
else:
    data = pandas.read_hdf('email_data.h5', "df")
print(data.head())    
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print(data.management.unique())
print(data.department.unique())
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga644ae1" class="outline-4"&gt;
&lt;h4 id="orga644ae1"&gt;Department Dummy Variables&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orga644ae1"&gt;
&lt;p&gt;
Even though I don't think it's going to prove useful, the &lt;code&gt;department&lt;/code&gt; feature is actually categorical, despite the use of integers so we'll have to use One-Hot-Encoding to add dummy variables for it.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;dummies_data = pandas.get_dummies(data, columns=["department"])
print(dummies_data.head(1))
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb540acb" class="outline-4"&gt;
&lt;h4 id="orgb540acb"&gt;Separating the Training and Prediction Sets&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgb540acb"&gt;
&lt;p&gt;
We're going to use the model to predict what the missing &lt;code&gt;management&lt;/code&gt; values are so I'm going to separate the missing and non-missing sets. 
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;training_data = dummies_data[pandas.notnull(dummies_data.management)]
prediction_data = dummies_data[pandas.isnull(dummies_data.management)]
print(training_data.shape)
print(prediction_data.shape)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
The problem description tells us that the answer should have 252 entries so this is a safe assertion.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assert len(prediction_data) == 252
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd47b865" class="outline-4"&gt;
&lt;h4 id="orgd47b865"&gt;Training and Target Data&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgd47b865"&gt;
&lt;p&gt;
To train the model we'll need to separate out the &lt;code&gt;management&lt;/code&gt; column (and remove it entirely from the &lt;code&gt;prediction&lt;/code&gt; set).
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;non_management = [column for column in training_data.columns if column != "management"]
y_train = training_data.management
x_train = training_data[non_management]
x_predict = prediction_data[non_management]
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org958c1f2" class="outline-4"&gt;
&lt;h4 id="org958c1f2"&gt;Scaling&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org958c1f2"&gt;
&lt;p&gt;
I don't think the Random Forest model that I'm going to use needs it, but I'm going to standardize the data.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;scaler = StandardScaler()
x_train = scaler.fit_transform(x_train)
x_predict = pandas.DataFrame(scaler.transform(x_predict), index=x_predict.index)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3cc1309" class="outline-4"&gt;
&lt;h4 id="org3cc1309"&gt;Feature Selection&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org3cc1309"&gt;
&lt;p&gt;
Since we now have so many features, I'm going to do some feature selection.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print(x_train.shape)
print(x_predict.shape)
trees = ExtraTreesClassifier(n_estimators=10)
eliminator = RFECV(estimator=trees, cv=StratifiedKFold(10), scoring="roc_auc")
eliminator.fit(x_train, y_train)
x_train_reduced = eliminator.transform(x_train)
x_predict_reduced = pandas.DataFrame(eliminator.transform(x_predict), index=x_predict.index)
print(x_train_reduced.shape)
print(x_predict_reduced.shape)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
When I used the train-test-split training model it left 17 columns. I wonder if using the whole training set messes it up.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0408205" class="outline-4"&gt;
&lt;h4 id="org0408205"&gt;Logistic Regression&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org0408205"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;model = LogisticRegressionCV(penalty="l1", scoring="roc_auc",
			     solver="liblinear", cv=StratifiedKFold(10))
model.fit(x_train_reduced, y_train)
print(model.scores_[1.0].mean())
print(model.scores_[1.0].std())
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
It seems to be doing much worse than when I used the train-test split.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3630724" class="outline-4"&gt;
&lt;h4 id="org3630724"&gt;Random Forests&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org3630724"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;parameter_grid = dict(n_estimators=range(10, 100, 10))
search = GridSearchCV(RandomForestClassifier(), parameter_grid,
		      cv=StratifiedKFold(10), scoring="roc_auc")
search.fit(x_train_reduced, y_train)
print(search.best_score_)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;class RandomForest(object):
    """builds the random forest

    Args:
     x_train(array): data to train on
     y_train(array): targets for training
     start (int): start value for number of estimators
     stop (int): upper value for range of estimators
     step (int): increment for range of estimators
     folds (int): K-folds for cross-validation    
    """
    def __init__(self, x_train, y_train,
		 start=10, stop=100, step=10, folds=10):
	self.x_train = x_train
	self.y_train = y_train
	self.start = start
	self.stop = stop
	self.step = step
	self.folds = folds
	self._parameters = None
	self._search = None
	self._model = None
	return

    @property
    def parameters(self):
	"""parameters for the grid-search"""
	if self._parameters is None:
	    self._parameters = dict(n_estimators=range(self.start,
						       self.stop,
						       self.step))
	return self._parameters

    @property
    def search(self):
	"""fitted grid search to find hyper-parameters"""
	if self._search is None:
	    self._search = GridSearchCV(RandomForestClassifier(),
					self.parameters,
					cv=StratifiedKFold(self.folds),
					scoring="roc_auc")
	    self._search.fit(self.x_train, self.y_train)
	return self._search

    @property
    def model(self):
	"""best model found by the grid search"""
	if self._model is None:
	    self._model = self.search.best_estimator_
	return self._model
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9d9e129" class="outline-4"&gt;
&lt;h4 id="org9d9e129"&gt;Data Loader&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org9d9e129"&gt;
&lt;p&gt;
Since having all these org-babel things around makes things kind of hard I'm going to make a class to bundle everything together.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;class DataLoader(object):
    """loads and transforms the data
    Args:
     estimators (int): number of trees to use for feature elimination
    """
    def __init__(self, estimators=10):
	self.estimators = estimators
	self._data = None
	self._dummies_data = None
	self._training_data = None
	self._prediction_data = None
	self._non_management = None
	self._y_train = None
	self._x_train = None
	self._x_predict = None
	self._scaler = None
	self._x_train_scaled = None
	self._x_predict_scaled = None
	self._eliminator = None
	self._x_train_reduced = None
	self._x_predict_reduced = None
	return

    @property
    def data(self):
	"""The initial data"""
	if self._data is None:
	    if not os.path.isfile("email_data.h5"):
		data = pandas.DataFrame(index=email.nodes())
		data["department"] = pandas.Series(networkx.get_node_attributes(email, "Department"))
		data["management"] = pandas.Series(networkx.get_node_attributes(email, "ManagementSalary"))
		data["clustering"] = pandas.Series(networkx.clustering(email))
		data["degree"] = pandas.Series(email.degree())
		data["degree_centrality"] = pandas.Series(networkx.degree_centrality(email))
		data["closeness_centrality"] = pandas.Series(networkx.closeness_centrality(email))
		data["betweenness_centrality"] = pandas.Series(networkx.betweenness_centrality(email))
		data["pagerank"] = pandas.Series(networkx.pagerank(email))
		_, authority = networkx.hits(email)
		data["authority"] = pandas.Series(authority)
		data.to_hdf("email_data.h5","df" )
		self._data = data
	    else:
		self._data = pandas.read_hdf('email_data.h5', "df")
	return self._data

    @property
    def dummies_data(self):
	"""one-hot-encoded data"""
	if self._dummies_data is None:
	    self._dummies_data = pandas.get_dummies(self.data, columns=["department"])
	return self._dummies_data

    @property
    def training_data(self):
	"""data with management information"""
	if self._training_data is None:
	    self._training_data = self.dummies_data[pandas.notnull(
		self.dummies_data.management)]
	return self._training_data

    @property
    def prediction_data(self):
	"""data missing management information"""
	if self._prediction_data is None:
	    self._prediction_data = self.dummies_data[pandas.isnull(
		self.dummies_data.management)]
	    assert len(self._prediction_data) == 252
	return self._prediction_data

    @property
    def non_management(self):
	"""list of columns minus management"""
	if self._non_management is None:
	    self._non_management = [
		column for column in self.training_data.columns
		if column != "management"]
	return self._non_management

    @property
    def y_train(self):
	"""target-data for training"""
	if self._y_train is None:
	    self._y_train = self.training_data.management
	return self._y_train

    @property
    def x_train(self):
	"""data for training"""
	if self._x_train is None:
	    self._x_train = self.training_data[self.non_management]
	return self._x_train

    @property
    def x_predict(self):
	"""set to make predictions"""
	if self._x_predict is None:
	    self._x_predict = self.prediction_data[self.non_management]
	return self._x_predict

    @property
    def scaler(self):
	"""standard scaler"""
	if self._scaler is None:
	    self._scaler = StandardScaler()
	return self._scaler

    @property
    def x_train_scaled(self):
	"""training data scaled to 1 std, 0 mean"""
	if self._x_train_scaled is None:
	    self._x_train_scaled = self.scaler.fit_transform(self.x_train)
	return self._x_train_scaled

    @property
    def x_predict_scaled(self):
	"""prediction data with mean 0, std 1

	The answer requires the index so this is a dataframe
	instead of an array

	Returns:
	 pandas.DataFrame: scaled data with index preserved
	"""
	if self._x_predict_scaled is None:
	    self._x_predict_scaled = pandas.DataFrame(
		self.scaler.transform(self.x_predict),
		index=self.x_predict.index)
	return self._x_predict_scaled

    @property
    def eliminator(self):
	"""recursive feature eliminator"""
	if self._eliminator is None:
	    trees = ExtraTreesClassifier(n_estimators=10)
	    self._eliminator = RFECV(estimator=trees, cv=StratifiedKFold(10), 
				     scoring="roc_auc")
	    self._eliminator.fit(self.x_train_scaled, self.y_train)
	return self._eliminator

    @property
    def x_train_reduced(self):
	"""training data with features eliminated"""
	if self._x_train_reduced is None:
	    self._x_train_reduced = self.eliminator.transform(
		self.x_train_scaled)
	return self._x_train_reduced

    @property
    def x_predict_reduced(self):
	"""prediction data with features eliminated"""
	if self._x_predict_reduced is None:
	    self._x_predict_reduced = pandas.DataFrame(
		self.eliminator.transform(self.x_predict_scaled),
		index=self.x_predict_scaled.index)
	return self._x_predict_reduced
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org82af0de" class="outline-4"&gt;
&lt;h4 id="org82af0de"&gt;Submission&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org82af0de"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def salary_predictions():
    """Prediction that employee is management

    Calculates the probability that an employee is management

    Returns:
     pandas.Series: Node ID, probability of node
    """
    data = DataLoader()
    forest = RandomForest(data.x_train_reduced, data.y_train)
    # probabilites is an array with rows of 
    # [&amp;lt;probability not management&amp;gt;, &amp;lt;probability management&amp;gt;]
    # see forest.model.classes_ to see what each entry represents
    probabilities = forest.model.predict_proba(data.x_predict_reduced)
    return pandas.Series(probabilities[:, 1], index=data.x_predict_reduced.index)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;output = salary_predictions()
print(output.head())
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assert all(output.index == DataLoader().prediction_data.index)
assert len(output) == 252
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org759157e" class="outline-3"&gt;
&lt;h3 id="org759157e"&gt;Part 2B - New Connections Prediction&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org759157e"&gt;
&lt;p&gt;
For the last part of this assignment, you will predict future connections between employees of the network. The future connections information has been loaded into the variable `future&lt;sub&gt;connections&lt;/sub&gt;`. The index is a tuple indicating a pair of nodes that currently do not have a connection, and the `Future Connection` column indicates if an edge between those two nodes will exist in the future, where a value of 1.0 indicates a future connection.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;future_connections = pandas.read_csv('Future_Connections.csv', index_col=0, converters={0: eval})
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print(future_connections.head(10))
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print(future_connections['Future Connection'].value_counts())
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;
Using network `G` and `future&lt;sub&gt;connections&lt;/sub&gt;`, identify the edges in `future&lt;sub&gt;connections&lt;/sub&gt;` with missing values and predict whether or not these edges will have a future connection.
&lt;/p&gt;

&lt;p&gt;
To accomplish this, you will need to create a matrix of features for the edges found in `future&lt;sub&gt;connections&lt;/sub&gt;` using networkx, train a sklearn classifier on those edges in `future&lt;sub&gt;connections&lt;/sub&gt;` that have `Future Connection` data, and predict a probability of the edge being a future connection for those edges in `future&lt;sub&gt;connections&lt;/sub&gt;` where `Future Connection` is missing.
&lt;/p&gt;

&lt;p&gt;
Your predictions will need to be given as the probability of the corresponding edge being a future connection.
&lt;/p&gt;

&lt;p&gt;
The evaluation metric for this assignment is the Area Under the ROC Curve (AUC).
&lt;/p&gt;

&lt;p&gt;
Your grade will be based on the AUC score computed for your classifier. A model which with an AUC of 0.75 or higher will receive full points.
&lt;/p&gt;

&lt;p&gt;
Using your trained classifier, return a series of length 122112 with the data being the probability of the edge being a future connection, and the index being the edge as represented by a tuple of nodes.
&lt;/p&gt;

&lt;pre class="example"&gt;
(107, 348)    0.35
(542, 751)    0.40
(20, 426)     0.55
(50, 989)     0.35
          ...
(939, 940)    0.15
(555, 905)    0.35
(75, 101)     0.65
Length: 122112, dtype: float64
&lt;/pre&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb76cec6" class="outline-4"&gt;
&lt;h4 id="orgb76cec6"&gt;Add Network Features&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgb76cec6"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;class Futures(object):
    target = "Future Connection"
    data_file = "Future_Connections.csv"
    graph_file = "email_prediction.txt"
    networkx_data_index = 2
    folds = 10
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;class DataNames(object):
    resource_allocation = 'resource_allocation'
    jaccard = 'jaccard_coefficient'
    adamic = "adamic_adar"
    preferential = "preferential_attachment"
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def add_networkx_data(adder, name, graph=email, frame=future_connections):
    """Adds networkx data to the frame

    The networkx link-prediction functions return generators of triples:
     (first-node, second-node, value)

    This will use the index of the frame that's passed in as the source of 
    node-pairs for the networkx function (called `ebunch` in the networkx
    documentation) and the add only the value we want back to the frame

    Args:
     adder: networkx function to call to get the new data
     name: column-name to add to the frame
     graph: networkx graph to pass to the function
     frame (pandas.DataFrame): frame with node-pairs as index to add data to
    """
    frame[name] = [output[Futures.networkx_data_index]
		   for output in adder(graph, frame.index)]
    return frame
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf8f486f" class="outline-5"&gt;
&lt;h5 id="orgf8f486f"&gt;Adding A Resource Allocation Index&lt;/h5&gt;
&lt;div class="outline-text-5" id="text-orgf8f486f"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;add_networkx_data(networkx.resource_allocation_index,
		  DataNames.resource_allocation)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print(future_connections.head(1))
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd96111a" class="outline-5"&gt;
&lt;h5 id="orgd96111a"&gt;Adding the Jaccard Coefficient&lt;/h5&gt;
&lt;div class="outline-text-5" id="text-orgd96111a"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;add_networkx_data(networkx.jaccard_coefficient, DataNames.jaccard)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print(future_connections.head(1))
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org651bbdb" class="outline-5"&gt;
&lt;h5 id="org651bbdb"&gt;Adamic Adar&lt;/h5&gt;
&lt;div class="outline-text-5" id="text-org651bbdb"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;add_networkx_data(networkx.adamic_adar_index, DataNames.adamic)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print(future_connections.head(1))
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgbb70ec8" class="outline-5"&gt;
&lt;h5 id="orgbb70ec8"&gt;Preferential Attachment&lt;/h5&gt;
&lt;div class="outline-text-5" id="text-orgbb70ec8"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;add_networkx_data(networkx.preferential_attachment, DataNames.preferential)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print(future_connections.head(1))
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgfcee2ed" class="outline-4"&gt;
&lt;h4 id="orgfcee2ed"&gt;Setup the Training and Testing Data&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgfcee2ed"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org3fb7468" class="outline-5"&gt;
&lt;h5 id="org3fb7468"&gt;Separating the Edges Without 'Future Connection' Values&lt;/h5&gt;
&lt;div class="outline-text-5" id="text-org3fb7468"&gt;
&lt;p&gt;
We are going to train on the values in the data with predictions and then make predictions for those that don't.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;prediction_set = future_connections[future_connections[Futures.target].isnull()]
training_set = future_connections[future_connections[Futures.target].notnull()]
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print(prediction_set.shape)
print(training_set.shape)
assert len(prediction_set) + len(training_set) == len(future_connections)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org974d867" class="outline-3"&gt;
&lt;h3 id="org974d867"&gt;Separate the Target and Training Sets&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org974d867"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;non_target = [column for column in future_connections.columns
	      if column != Futures.target]
x_train = training_set[non_target]
y_train = training_set[Futures.target]
x_predict = prediction_set[non_target]
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assert all(x_train.columns == x_predict.columns)
assert len(x_train) == len(x_test)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org61bd2bb" class="outline-3"&gt;
&lt;h3 id="org61bd2bb"&gt;Scaling the Data&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org61bd2bb"&gt;
&lt;p&gt;
To enable the use of linear models I'm going to scale the data so the mean is 0 and the variance is 1.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;scaler = StandardScaler()
x_train_scaled = scaler.fit_transform(x_train)
x_predict_scaled = scaler.transform(x_predict)

x_train_frame = pandas.DataFrame(x_train_scaled, columns=x_train.columns)
x_predict_frame = pandas.DataFrame(x_predict_scaled, columns=x_predict.columns)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print(training.describe())
print(predictions.describe())
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb71a6eb" class="outline-3"&gt;
&lt;h3 id="orgb71a6eb"&gt;Feature Selection&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb71a6eb"&gt;
&lt;p&gt;
To reduce the dimensionality I'm going to use model-based selection with Extra Trees.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;estimator = ExtraTreesClassifier()
estimator.fit(x_train_scaled, y_train)
selector = SelectFromModel(estimator, prefit=True)
x_train_trees_sfm = selector.transform(x_train_scaled)
x_predict_sfm = selector.transform(x_predict_scaled)
print(estimator.feature_importances_)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print(x_train_trees_sfm.shape)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org39fc4fa" class="outline-4"&gt;
&lt;h4 id="org39fc4fa"&gt;Missing Future Connections&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org39fc4fa"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;model = LogisticRegressionCV(n_jobs=-1, scoring='roc_auc', solver='liblinear',
			     cv=StratifiedKFold())
model.fit(x_train_trees_sfm, y_train)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for scores in model.scores_[1.0]:
    print(max(scores))
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print(model.classes_)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def new_connections_predictions():    
    probabilities = model.predict_proba(x_predict_sfm)
    return pandas.Series(probabilities[:, 1], index=prediction_set.index)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;outcome = new_connections_predictions()
assert len(outcome) == 122112, len(outcome)
print(outcome.head())
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>networks</category><category>random graphs</category><guid>https://necromuralist.github.io/Visions-Voices-Data/posts/networks/looking-at-random-graphs/</guid><pubDate>Sat, 13 Apr 2019 18:59:44 GMT</pubDate></item></channel></rss>