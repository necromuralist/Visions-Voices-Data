<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#">
<head>
<meta charset="utf-8">
<meta content="Adumbrations of data." name="description">
<meta content="width=device-width, initial-scale=1" name="viewport">
<title>Visions, Voices, Data</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="assets/css/ipython.min.css" rel="stylesheet" type="text/css">
<link href="assets/css/nikola_ipython.css" rel="stylesheet" type="text/css">
<meta content="#5670d4" name="theme-color">
<meta content="Nikola (getnikola.com)" name="generator">
<link href="rss.xml" rel="alternate" title="RSS" type="application/rss+xml">
<link href="https://necromuralist.github.io/Visions-Voices-Data/" rel="canonical">
<link href="index-3.html" rel="next" type="text/html"><!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script><!--
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.9.0/p5.min.js"
</script>
-->
<script async src="javascript/p5.min.js" type="text/javascript"></script>
<link href="/posts/web-scraping/web-scraping-assignment-1/" rel="prefetch" type="text/html">
</head>
<body>
<a class="sr-only sr-only-focusable" href="#content">Skip to main content</a> <!-- Menubar -->
<nav class="navbar navbar-expand-md static-top mb-4 navbar-light bg-light">
<div class="container"><!-- This keeps the margins nice -->
 <a class="navbar-brand" href="https://necromuralist.github.io/Visions-Voices-Data/"><span id="blog-title">Visions, Voices, Data</span></a> <button aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation" class="navbar-toggler" data-target="#bs-navbar" data-toggle="collapse" type="button"><span class="navbar-toggler-icon"></span></button>
<div class="collapse navbar-collapse" id="bs-navbar">
<ul class="navbar-nav mr-auto">
<li class="nav-item"><a class="nav-link" href="/archive.html">Archive</a></li>
<li class="nav-item"><a class="nav-link" href="/categories/">Tags</a></li>
<li class="nav-item"><a class="nav-link" href="/rss.xml">RSS feed</a></li>
<li class="nav-item dropdown"><a aria-expanded="false" aria-haspopup="true" class="nav-link dropdown-toggle" data-toggle="dropdown" href="#">Pages</a>
<div class="dropdown-menu"><a class="dropdown-item active" href="/">Cloistered Monkey <span class="sr-only">(active)</span></a> <a class="dropdown-item" href="/pages/giss/giss-yearly-anomalies-by-climate-zone">GISS Anomalies</a></div>
</li>
</ul>
<!-- DuckDuckGo custom search -->
<form action="https://duckduckgo.com/" class="navbar-form pull-left" id="search" method="get" name="search"><input name="sites" type="hidden" value="https://necromuralist.github.io/Visions-Voices-Data/"> <input name="k8" type="hidden" value="#444444"> <input name="k9" type="hidden" value="#D51920"> <input name="kt" type="hidden" value="h"> <input class="span2" maxlength="255" name="q" placeholder="Search…" type="text"> <input style="visibility: hidden;display:none" type="submit" value="DuckDuckGo Search"></form>
<!-- End of custom search -->
<ul class="navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse --></div>
<!-- /.container --></nav>
<!-- End of Menubar -->
<div class="container" id="content" role="main">
<div class="body-content"><!--Body content-->
<div class="postindex">
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="/posts/web-scraping/web-scraping-assignment-1/">Web Scraping Assignment 1</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="/posts/web-scraping/web-scraping-assignment-1/" rel="bookmark"><time class="published dt-published" datetime="2019-08-03T12:07:56-07:00" itemprop="datePublished" title="2019-08-03 12:07">2019-08-03 12:07</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="/posts/web-scraping/web-scraping-assignment-1/#org352760d">Beginning</a>
<ul>
<li><a href="/posts/web-scraping/web-scraping-assignment-1/#orgfe04f84">Imports</a>
<ul>
<li><a href="/posts/web-scraping/web-scraping-assignment-1/#orge2145f2">Python</a></li>
<li><a href="/posts/web-scraping/web-scraping-assignment-1/#org04feb6f">PyPi</a></li>
</ul>
</li>
<li><a href="/posts/web-scraping/web-scraping-assignment-1/#orgaa63aee">Setup</a>
<ul>
<li><a href="/posts/web-scraping/web-scraping-assignment-1/#org640bff9">The URLs</a></li>
<li><a href="/posts/web-scraping/web-scraping-assignment-1/#org4102cd8">The Expected</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/posts/web-scraping/web-scraping-assignment-1/#org0ba3141">Middle</a>
<ul>
<li><a href="/posts/web-scraping/web-scraping-assignment-1/#org284d163">The Sample</a>
<ul>
<li><a href="/posts/web-scraping/web-scraping-assignment-1/#org143fc40">The Way I Would Do It</a></li>
<li><a href="/posts/web-scraping/web-scraping-assignment-1/#org6b8841a">The Assignment Way</a></li>
</ul>
</li>
<li><a href="/posts/web-scraping/web-scraping-assignment-1/#org2e101c6">The Assignment</a>
<ul>
<li><a href="/posts/web-scraping/web-scraping-assignment-1/#orgd60f7b6">Requests HTML</a></li>
<li><a href="/posts/web-scraping/web-scraping-assignment-1/#org9d4bed2">Urllib</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/posts/web-scraping/web-scraping-assignment-1/#org772756e">End</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org352760d">
<h2 id="org352760d">Beginning</h2>
<div class="outline-text-2" id="text-org352760d">
<p>The goal of this exercise is to find all the <code>&lt;span&gt;</code> tags on a page and sum the numbers they contain.</p>
</div>
<div class="outline-3" id="outline-container-orgfe04f84">
<h3 id="orgfe04f84">Imports</h3>
<div class="outline-text-3" id="text-orgfe04f84"></div>
<div class="outline-4" id="outline-container-orge2145f2">
<h4 id="orge2145f2">Python</h4>
<div class="outline-text-4" id="text-orge2145f2">
<div class="highlight">
<pre><span></span>import urllib
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org04feb6f">
<h4 id="org04feb6f">PyPi</h4>
<div class="outline-text-4" id="text-org04feb6f">
<div class="highlight">
<pre><span></span>from bs4 import BeautifulSoup
from expects import (
    equal,
    expect,
    be_true,
)
from requests_html import HTMLSession
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-orgaa63aee">
<h3 id="orgaa63aee">Setup</h3>
<div class="outline-text-3" id="text-orgaa63aee"></div>
<div class="outline-4" id="outline-container-org640bff9">
<h4 id="org640bff9">The URLs</h4>
<div class="outline-text-4" id="text-org640bff9">
<div class="highlight">
<pre><span></span>SAMPLE_URL = " http://py4e-data.dr-chuck.net/comments_42.html"
ACTUAL_URL = "http://py4e-data.dr-chuck.net/comments_260442.html"
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org4102cd8">
<h4 id="org4102cd8">The Expected</h4>
<div class="outline-text-4" id="text-org4102cd8">
<div class="highlight">
<pre><span></span>SAMPLE_EXPECTED = 2553
ACTUAL_EXPECTED_LAST_DIGIT = 5
</pre></div>
</div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org0ba3141">
<h2 id="org0ba3141">Middle</h2>
<div class="outline-text-2" id="text-org0ba3141"></div>
<div class="outline-3" id="outline-container-org284d163">
<h3 id="org284d163">The Sample</h3>
<div class="outline-text-3" id="text-org284d163"></div>
<div class="outline-4" id="outline-container-org143fc40">
<h4 id="org143fc40">The Way I Would Do It</h4>
<div class="outline-text-4" id="text-org143fc40">
<div class="highlight">
<pre><span></span>def using_requests(url: str) -&gt; int:
    """get the span total

    Args:
     url: The URL for the page

    Returns:
     the total sum
    """
    session = HTMLSession()
    response = session.get(url)
    expect(response.ok).to(be_true)
    total = 0

    for count, span in enumerate(response.html.find("span")):
        total += int(span.text)

    print(f"Count: {count + 1}")
    print(f"Sum: {total}")
    return total
</pre></div>
<div class="highlight">
<pre><span></span>total = using_requests(SAMPLE_URL)
expect(total).to(equal(SAMPLE_EXPECTED))
</pre></div>
<pre class="example">
Count: 50
Sum: 2553

</pre></div>
</div>
<div class="outline-4" id="outline-container-org6b8841a">
<h4 id="org6b8841a">The Assignment Way</h4>
<div class="outline-text-4" id="text-org6b8841a">
<p>For this kind of thing, using urllib isn't really much more work, I'm used to the older python 2 version which (maybe only seemed at the time) was more complicated to use.</p>
<div class="highlight">
<pre><span></span>def using_urllib(url: str) -&gt; int:
    """get the span total with urllib and beautiful soup

    Args:
     url: the URL for the page

    Returns:
     the total of the span contents
    """
    response = urllib.request.urlopen(url)
    soup = BeautifulSoup(response.read(), "html.parser")
    total = 0
    for count, span in enumerate(soup.find_all("span")):
        total += int(span.text)

    print(f"Count: {count + 1}")
    print(f"Sum: {total}")
    return total
</pre></div>
<div class="highlight">
<pre><span></span>total = using_urllib(SAMPLE_URL)
expect(total).to(equal(SAMPLE_EXPECTED))
</pre></div>
<pre class="example">
Count: 50
Sum: 2553

</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org2e101c6">
<h3 id="org2e101c6">The Assignment</h3>
<div class="outline-text-3" id="text-org2e101c6"></div>
<div class="outline-4" id="outline-container-orgd60f7b6">
<h4 id="orgd60f7b6">Requests HTML</h4>
<div class="outline-text-4" id="text-orgd60f7b6">
<div class="highlight">
<pre><span></span>total = using_requests(ACTUAL_URL)
expect(int(str(total)[-1])).to(equal(ACTUAL_EXPECTED_LAST_DIGIT))
</pre></div>
<pre class="example">
Count: 50
Sum: 2305

</pre></div>
</div>
<div class="outline-4" id="outline-container-org9d4bed2">
<h4 id="org9d4bed2">Urllib</h4>
<div class="outline-text-4" id="text-org9d4bed2">
<div class="highlight">
<pre><span></span>total = using_urllib(ACTUAL_URL)
expect(int(str(total)[-1])).to(equal(ACTUAL_EXPECTED_LAST_DIGIT))
</pre></div>
<pre class="example">
Count: 50
Sum: 2305

</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org772756e">
<h2 id="org772756e">End</h2>
<div class="outline-text-2" id="text-org772756e">
<p>Although I normally use <code>requests</code> or <code>requests-html</code>, I must say that the <code>urllib</code> version with <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/">BeautifulSoup</a> for this particular exercise wasn't much different.</p>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="/posts/web-scraping/web-scraping-assignment-2/">Web Scraping Assignment 2</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="/posts/web-scraping/web-scraping-assignment-2/" rel="bookmark"><time class="published dt-published" datetime="2019-08-02T13:43:01-07:00" itemprop="datePublished" title="2019-08-02 13:43">2019-08-02 13:43</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="/posts/web-scraping/web-scraping-assignment-2/#orge963253">Beginning</a>
<ul>
<li><a href="/posts/web-scraping/web-scraping-assignment-2/#org8433374">Imports</a>
<ul>
<li><a href="/posts/web-scraping/web-scraping-assignment-2/#org04e5580">Python</a></li>
<li><a href="/posts/web-scraping/web-scraping-assignment-2/#org264839a">PyPi</a></li>
</ul>
</li>
<li><a href="/posts/web-scraping/web-scraping-assignment-2/#orgff32d65">Setup</a>
<ul>
<li><a href="/posts/web-scraping/web-scraping-assignment-2/#org89ae143">The URL</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/posts/web-scraping/web-scraping-assignment-2/#orgabe8dd0">Middle</a>
<ul>
<li><a href="/posts/web-scraping/web-scraping-assignment-2/#orgcc42471">The Sample Exercise</a>
<ul>
<li><a href="/posts/web-scraping/web-scraping-assignment-2/#org83df5a1">The Easy Way</a></li>
<li><a href="/posts/web-scraping/web-scraping-assignment-2/#org19809c4">The Slightly Less Easy Way</a></li>
</ul>
</li>
<li><a href="/posts/web-scraping/web-scraping-assignment-2/#org45d41f3">The Real One</a>
<ul>
<li><a href="/posts/web-scraping/web-scraping-assignment-2/#org71f3761">The Easy Way</a></li>
<li><a href="/posts/web-scraping/web-scraping-assignment-2/#org82ae5d5">The Assignment Way</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/posts/web-scraping/web-scraping-assignment-2/#org3222b0a">End</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-orge963253">
<h2 id="orge963253">Beginning</h2>
<div class="outline-text-2" id="text-orge963253">
<p>The goal of this exercise is to crawl through a set of anchor links to get a particular name stored in the <i>nth</i> anchor tag. The assignment specifically says to use <a href="https://docs.python.org/3/library/urllib.html">urllib</a> but, if you go to the documentation for <a href="https://docs.python.org/3/library/urllib.request.html#module-urllib.request">urllib.request</a> it tells you to use to use <a href="https://2.python-requests.org/en/master/">requests</a>, which, if you go to its documentation says that it's in maintenance mode while work is being done on <a href="https://3.python-requests.org/">Requests III</a>… anyway, I like using <a href="https://html.python-requests.org/">Requests-HTML</a> so I'll use that and urllib side-by-side.</p>
</div>
<div class="outline-3" id="outline-container-org8433374">
<h3 id="org8433374">Imports</h3>
<div class="outline-text-3" id="text-org8433374"></div>
<div class="outline-4" id="outline-container-org04e5580">
<h4 id="org04e5580">Python</h4>
<div class="outline-text-4" id="text-org04e5580">
<div class="highlight">
<pre><span></span><span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">urllib</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org264839a">
<h4 id="org264839a">PyPi</h4>
<div class="outline-text-4" id="text-org264839a">
<div class="highlight">
<pre><span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
<span class="kn">from</span> <span class="nn">requests_html</span> <span class="kn">import</span> <span class="n">HTMLSession</span>
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-orgff32d65">
<h3 id="orgff32d65">Setup</h3>
<div class="outline-text-3" id="text-orgff32d65"></div>
<div class="outline-4" id="outline-container-org89ae143">
<h4 id="org89ae143">The URL</h4>
<div class="outline-text-4" id="text-org89ae143">
<div class="highlight">
<pre><span></span><span class="n">BASE_URL</span> <span class="o">=</span> <span class="s2">"http://py4e-data.dr-chuck.net/known_by_"</span>
<span class="n">SAMPLE_URL</span> <span class="o">=</span> <span class="n">f</span><span class="s2">"{BASE_URL}Fikret.html"</span>
<span class="n">ASSIGNMENT_URL</span> <span class="o">=</span> <span class="n">f</span><span class="s2">"{BASE_URL}Abdalroof.html"</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-orgabe8dd0">
<h2 id="orgabe8dd0">Middle</h2>
<div class="outline-text-2" id="text-orgabe8dd0"></div>
<div class="outline-3" id="outline-container-orgcc42471">
<h3 id="orgcc42471">The Sample Exercise</h3>
<div class="outline-text-3" id="text-orgcc42471"></div>
<div class="outline-4" id="outline-container-org83df5a1">
<h4 id="org83df5a1">The Easy Way</h4>
<div class="outline-text-4" id="text-org83df5a1">
<div class="highlight">
<pre><span></span><span class="n">session</span> <span class="o">=</span> <span class="n">HTMLSession</span><span class="p">()</span>
<span class="n">response</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">SAMPLE_URL</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">ok</span>

<span class="n">expression</span> <span class="o">=</span> <span class="s2">"_(?P&lt;name&gt;[^_.]+).html"</span>
<span class="n">expression</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">"Name: {expression.search(SAMPLE_URL).group('name')}"</span><span class="p">)</span>

<span class="k">for</span> <span class="n">hop</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">links</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">html</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">"a"</span><span class="p">)</span>

    <span class="n">link_element</span> <span class="o">=</span> <span class="n">links</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">"Name: {link_element.text}"</span><span class="p">)</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">link_element</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">"href"</span><span class="p">])</span>

<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">"Final Answer: {link_element.text}"</span><span class="p">)</span>
</pre></div>
<pre class="example">
Name: Fikret
Name: Montgomery
Name: Mhairade
Name: Butchi
Name: Anayah
Final Answer: Anayah

</pre></div>
</div>
<div class="outline-4" id="outline-container-org19809c4">
<h4 id="org19809c4">The Slightly Less Easy Way</h4>
<div class="outline-text-4" id="text-org19809c4">
<div class="highlight">
<pre><span></span><span class="n">response</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">SAMPLE_URL</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">"Name: {expression.search(SAMPLE_URL).group('name')}"</span><span class="p">)</span>
<span class="k">for</span> <span class="n">hop</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
   <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">read</span><span class="p">(),</span> <span class="s2">"html.parser"</span><span class="p">)</span>
   <span class="n">link_element</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">"a"</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> 
   <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">"Name: {link_element.text}"</span><span class="p">)</span>
   <span class="n">response</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">link_element</span><span class="p">[</span><span class="s2">"href"</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">"</span><span class="se">\n</span><span class="s2">Final Answer: {link_element.text}"</span><span class="p">)</span>
</pre></div>
<pre class="example">
Name: Fikret
Name: Montgomery
Name: Mhairade
Name: Butchi
Name: Anayah

Final Answer: Anayah

</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org45d41f3">
<h3 id="org45d41f3">The Real One</h3>
<div class="outline-text-3" id="text-org45d41f3"></div>
<div class="outline-4" id="outline-container-org71f3761">
<h4 id="org71f3761">The Easy Way</h4>
<div class="outline-text-4" id="text-org71f3761">
<div class="highlight">
<pre><span></span><span class="n">session</span> <span class="o">=</span> <span class="n">HTMLSession</span><span class="p">()</span>
<span class="n">response</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ASSIGNMENT_URL</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">ok</span>

<span class="n">expression</span> <span class="o">=</span> <span class="s2">"_(?P&lt;name&gt;[^_.]+).html"</span>
<span class="n">expression</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">"Name: {expression.search(ASSIGNMENT_URL).group('name')}"</span><span class="p">)</span>

<span class="k">for</span> <span class="n">hop</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">):</span>
    <span class="n">links</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">html</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">"a"</span><span class="p">)</span>

    <span class="n">link_element</span> <span class="o">=</span> <span class="n">links</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">"Name: {link_element.text}"</span><span class="p">)</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">link_element</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">"href"</span><span class="p">])</span>

<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">"Final Answer: {link_element.text}"</span><span class="p">)</span>
</pre></div>
<pre class="example">
Name: Abdalroof
Name: Billi
Name: Jayse
Name: Amaarah
Name: Cesar
Name: Rosheen
Name: Mohamed
Name: Kiara
Final Answer: Kiara

</pre></div>
</div>
<div class="outline-4" id="outline-container-org82ae5d5">
<h4 id="org82ae5d5">The Assignment Way</h4>
<div class="outline-text-4" id="text-org82ae5d5">
<div class="highlight">
<pre><span></span><span class="n">HOPS</span> <span class="o">=</span> <span class="mi">7</span>
<span class="n">FIND_AT_INDEX</span> <span class="o">=</span> <span class="mi">18</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">response</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">ASSIGNMENT_URL</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">"Name: {expression.search(ASSIGNMENT_URL).group('name')}"</span><span class="p">)</span>
<span class="k">for</span> <span class="n">hop</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">HOPS</span><span class="p">):</span>
   <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">read</span><span class="p">(),</span> <span class="s2">"html.parser"</span><span class="p">)</span>
   <span class="n">link_element</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">"a"</span><span class="p">)[</span><span class="n">FIND_AT_INDEX</span><span class="p">]</span> 
   <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">"Name: {link_element.text}"</span><span class="p">)</span>
   <span class="n">response</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">link_element</span><span class="p">[</span><span class="s2">"href"</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">"</span><span class="se">\n</span><span class="s2">Final Answer: {link_element.text}"</span><span class="p">)</span>
</pre></div>
<pre class="example">
Name: Abdalroof
Name: Billi
Name: Jayse
Name: Amaarah
Name: Cesar
Name: Rosheen
Name: Mohamed
Name: Kiara

Final Answer: Kiara
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org3222b0a">
<h2 id="org3222b0a">End</h2>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="/posts/nature-of-code/nested-follower/">Nested follower</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="/posts/nature-of-code/nested-follower/" rel="bookmark"><time class="published dt-published" datetime="2019-07-23T13:49:03-07:00" itemprop="datePublished" title="2019-07-23 13:49">2019-07-23 13:49</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="/posts/nature-of-code/nested-follower/#org8743d8f">Beginning</a>
<ul>
<li><a href="/posts/nature-of-code/nested-follower/#org1370d13">Create A Walker</a></li>
<li><a href="/posts/nature-of-code/nested-follower/#org63dd93e">Specifications</a></li>
</ul>
</li>
<li><a href="/posts/nature-of-code/nested-follower/#orgdfb08ae">Middle</a></li>
<li><a href="/posts/nature-of-code/nested-follower/#org369ff3b">End</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org8743d8f">
<h2 id="org8743d8f">Beginning</h2>
<div class="outline-text-2" id="text-org8743d8f">
<p>This is assignment 1 from the Nature of Code course on Kadenze. I was originally going to make it a mouse-follower but I re-read the instructions and it seems like it's better to make it a random-walker. These are the requirements:</p>
</div>
<div class="outline-3" id="outline-container-org1370d13">
<h3 id="org1370d13">Create A Walker</h3>
<div class="outline-text-3" id="text-org1370d13">
<ul class="org-ul">
<li>Create an object that moves around the screen</li>
<li>Incorporate randomness or perlin noise</li>
</ul>
</div>
</div>
<div class="outline-3" id="outline-container-org63dd93e">
<h3 id="org63dd93e">Specifications</h3>
<div class="outline-text-3" id="text-org63dd93e">
<ul class="org-ul">
<li>Needs to be visually different from the Nature of Code examples</li>
<li>Use comments</li>
<li>Only use <code>p5.js</code> libraries</li>
</ul>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-orgdfb08ae">
<h2 id="orgdfb08ae">Middle</h2>
<div class="outline-text-2" id="text-orgdfb08ae">
<script language="javascript" src="/posts/nature-of-code/nested-follower/follower.js" type="text/javascript"></script>
<div id="nested-follower"></div>
<div class="highlight">
<pre><span></span>/**
 * Random Walker
 *
 * This is an implementation of the Random Walker based on the example given in
 * "The Nature of Code"
 */

// This is the div where the canvas will be placed
let nested_parent_div_id = "nested-follower";

/**
 * The sketch creator
 * 
 * @param {P5} p
 */
let nested_follower_sketch = function(p) {
    /**
     * Setup the canvas
     *
     * - Attaches the canvas to the div
     * - Creates the walker objects
     */
    p.setup = function() {
        this.canvas = p.createCanvas($("#" + nested_parent_div_id).outerWidth(true), 800);
        p.parent = new NoiseWalker(p);
        p.followers = [new Follower(p, p.parent), new Follower(p, p.parent), new Follower(p, p.parent)];
    };

    /**
     * Refresh the objects by calling their update functions
     *
     * This also clears the background.
     */
    p.draw = function() {
        p.background(255);
        p.parent.update();
        p.followers.forEach(function(follower) {
            follower.update();
        });
    };
};

/**
 * The main walker (with perlin noise)
 *
 * @param {P5} p
 */
function NoiseWalker(p) {
    this.position = p.createVector(p.width/2, p.height/2);
    this.velocity = p.createVector(0, 0);
    this.weight = p.round(p.random(5, 10));
    this.time_x = 0;
    this.time_y = 10000;
    this.time_delta = 0.01;
    this.acceleration = p.createVector(0, 0);
    this.max_acceleration = 0.001;

    /**
     * Updates the walker's position
     */
    this.walk = function() {
        // set the acceleration using perlin noise
        this.acceleration.x = p.map(p.noise(this.time_x), 0, 1, 0, this.max_acceleration);
        this.acceleration.y = p.map(p.noise(this.time_y), 0, 1, 0, this.max_acceleration);
        console.log(this.acceleration)
        // update the time
        this.time_x += this.time_delta;
        this.time_y += this.time_delta;

        // setMag always produces the same magnitude (but the orientation stays the same)
        // this.acceleration.setMag(this.magnitude);

        this.velocity = this.velocity.add(this.acceleration);
        this.position = this.position.add(this.velocity);

        // keep it within the window
        if (this.position.x &lt; 0)
            this.position.x = p.width;
        else if (this.position.x &gt; p.width)
            this.position.x = 0;
        if (this.position.y &lt; 0)
            this.position.y = p.height;
        else if (this.position.y &gt; p.height)
            this.position.y = 0;
    };

    /**
     * draws the walker
     */
    this.display = function() {
        p.stroke(0);
        //p.background(255, 255, 255, 10);
        p.point(this.position.x, this.position.y);
    };

    /**
     * Calls the walk and update functions
     */
    this.update = function() {
        this.walk();
        this.display();
    };
}


/**
 * A follower that follows a parent object
 *
 * @param {P5} p
 * @param {NoiseWalker} parent
 */
function Follower(p, parent) {
    this.parent = parent;
    this.variance = p.random(5);
    this.position = p.createVector(
        this.parent.position.x + p.random(-this.variance, this.variance),
        this.parent.position.y + p.random(-this.variance, this.variance));
    this.velocity = p.createVector(0, 0);
    this.magnitude = p.random(0.05, 0.09);

    // some colors to cycle through
    this.red = [63, 123, 191, 191, 191];
    this.green = [63, 63, 63, 63, 63];
    this.blue = [191, 191, 191, 127, 63];
    this.colors = this.red.length;
    this.color = p.round(p.random(this.colors));

    /**
     * Moves the Follower
     *
     * sets the acceleration by pointing to the parent's position
     */
    this.walk = function() {
        let acceleration = p5.Vector.sub(this.parent.position, this.position);

        // acceleration.setMag(this.magnitude);
        this.velocity = this.velocity.add(acceleration);
        this.position = this.position.add(this.velocity);
    };

    /**
     * Display the Follower
     *
     * cycles through the colors as we go
     */
    this.display = function() {
        p.strokeWeight(p.random(this.variance, 2 * this.variance));
        p.stroke(this.red[this.color], this.green[this.color], this.blue[this.color]);
        this.color = (this.color + 1) % this.colors;
        p.noFill();
        p.ellipse(this.position.x, this.position.y, p.random(10, 45), p.random(10, 45));
    };

    /**
     * calls the update and walk 
     */
    this.update = function() {
        this.walk();
        this.display();
    };
}

new p5(nested_follower_sketch, nested_parent_div_id);
</pre></div>
<div class="outline-2" id="outline-container-org369ff3b">
<h2 id="org369ff3b">End</h2>
</div>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="posts/nature-of-code/a-mouse-follower/">A Mouse Follower</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="posts/nature-of-code/a-mouse-follower/" rel="bookmark"><time class="published dt-published" datetime="2019-07-21T16:03:37-07:00" itemprop="datePublished" title="2019-07-21 16:03">2019-07-21 16:03</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="posts/nature-of-code/a-mouse-follower/#org8ff362e">Beginning</a></li>
<li><a href="posts/nature-of-code/a-mouse-follower/#org1ccaf14">Middle</a></li>
<li><a href="posts/nature-of-code/a-mouse-follower/#org8abadfb">End</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org8ff362e">
<h2 id="org8ff362e">Beginning</h2>
<div class="outline-text-2" id="text-org8ff362e">
<p>Instead of a random walker this walker will be attracted (somewhat) to the mouse cursor.</p>
</div>
</div>
<div class="outline-2" id="outline-container-org1ccaf14">
<h2 id="org1ccaf14">Middle</h2>
<div class="outline-text-2" id="text-org1ccaf14">
<script language="javascript" src="posts/nature-of-code/a-mouse-follower/follower.js" type="text/javascript"></script>
<div id="mouse-follower"></div>
<div class="highlight">
<pre><span></span>let parent_div_id = "mouse-follower";

let mouse_follower_sketch = function(p) {
    p.setup = function() {
        this.canvas = p.createCanvas($("#" + parent_div_id).outerWidth(true), 800);
        p.walker = new MouseWalker(p);
    }

    p.draw = function() {
        p.background(255);
        p.walker.walk();
        p.walker.display();
    }
};

function MouseWalker(p) {
    this.position = p.createVector(p.width/2, p.height/2);
    this.velocity = p.createVector(0, 0)

    this.walk = function() {
        mouse = p.createVector(p.mouseX, p.mouseY);
        // calling sub on the vectors does an in-place update
        // using p5.Vector.sub creates a new vector
        // This is a static method so we use the module (p5) not the instance (p)
        acceleration = mouse.sub(this.position);

        // setMag always produces the same magnitude (but the orientation stays the same)
        acceleration.setMag(0.1);
        this.velocity = this.velocity.add(acceleration);
        this.position = this.position.add(this.velocity)
  }

  this.display = function() {
      p.stroke(0);
      p.noFill();
      p.background(255, 255, 255, 25);
      p.ellipse(this.position.x, this.position.y, 48, 48);
  }
}

sketch_container = new p5(mouse_follower_sketch, parent_div_id);
</pre></div>
</div>
</div>
<div class="outline-2" id="outline-container-org8abadfb">
<h2 id="org8abadfb">End</h2>
<div class="outline-text-2" id="text-org8abadfb">
<ol class="org-ol">
<li>Shiffman D. <a href="https://natureofcode.com/">The nature of code</a>: simulating natural systems with processing. Version 1.0, generated December 6, 2012. s.l.: Selbstverl.; 2012. 498 p.</li>
</ol>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="posts/nature-of-code/a-random-accelerator/">A Random Accelerator</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="posts/nature-of-code/a-random-accelerator/" rel="bookmark"><time class="published dt-published" datetime="2019-07-21T15:14:42-07:00" itemprop="datePublished" title="2019-07-21 15:14">2019-07-21 15:14</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="posts/nature-of-code/a-random-accelerator/#org9518eca">Beginning</a></li>
<li><a href="posts/nature-of-code/a-random-accelerator/#org5c7540c">Middle</a></li>
<li><a href="posts/nature-of-code/a-random-accelerator/#org5f3a24f">End</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org9518eca">
<h2 id="org9518eca">Beginning</h2>
<div class="outline-text-2" id="text-org9518eca">
<p>This is an extension of the random walker with acceleration added.</p>
</div>
</div>
<div class="outline-2" id="outline-container-org5c7540c">
<h2 id="org5c7540c">Middle</h2>
<div class="outline-text-2" id="text-org5c7540c">
<script language="javascript" src="posts/nature-of-code/a-random-accelerator/walker.js" type="text/javascript"></script>
<div id="random-accelerator"></div>
<div class="highlight">
<pre><span></span>let random_accelerator_sketch = function(p) {
    p.setup = function() {
        let parent_div_id = "random-accelerator";
        this.canvas = p.createCanvas($("#" + parent_div_id).outerWidth(true), 800);
        this.canvas.parent(parent_div_id);
        p.walker = new Walker(p);
    }

    p.draw = function() {
        p.background(255);
        p.walker.walk();
        p.walker.display();
    }
};

function Walker(p) {
    this.position = p.createVector(p.width/2, p.height/2);
    this.velocity = p.createVector(0, 0)

    this.walk = function() {
        acceleration = p.createVector(p.random(-1, 1), p.random(-1, 1));
        acceleration = acceleration.mult(0.1)
        this.velocity = this.velocity.add(acceleration)
        this.position = this.position.add(this.velocity)
  }

  this.display = function() {
      p.stroke(0);
      p.noFill();
      p.background(255, 255, 255, 25);
      p.ellipse(this.position.x, this.position.y, 48, 48);
  }
}

sketch_container = new p5(random_accelerator_sketch, 'random-accelerator');
</pre></div>
</div>
</div>
<div class="outline-2" id="outline-container-org5f3a24f">
<h2 id="org5f3a24f">End</h2>
<div class="outline-text-2" id="text-org5f3a24f">
<p>This was a very rudimentary walker, the main point of it was that at this point we have the basic kinematic elements to make something following the rules of classical physics (more or less).</p>
<ol class="org-ol">
<li>Shiffman D. <a href="https://natureofcode.com/">The nature of code</a>: simulating natural systems with processing. Version 1.0, generated December 6, 2012. s.l.: Selbstverl.; 2012. 498 p.</li>
</ol>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="posts/nature-of-code/a-random-walker/">A Random Walk(er)</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="posts/nature-of-code/a-random-walker/" rel="bookmark"><time class="published dt-published" datetime="2019-07-21T12:29:09-07:00" itemprop="datePublished" title="2019-07-21 12:29">2019-07-21 12:29</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="posts/nature-of-code/a-random-walker/#org7f4ab1a">Beginning</a></li>
<li><a href="posts/nature-of-code/a-random-walker/#org3d7a5b6">Middle</a>
<ul>
<li><a href="posts/nature-of-code/a-random-walker/#org5a3f18e">A Div to Locate the Sketch</a></li>
<li><a href="posts/nature-of-code/a-random-walker/#org7d41e77">The Javascript</a></li>
</ul>
</li>
<li><a href="posts/nature-of-code/a-random-walker/#orgfb4bb0c">End</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org7f4ab1a">
<h2 id="org7f4ab1a">Beginning</h2>
<div class="outline-text-2" id="text-org7f4ab1a">
<p>This is another post to see if I understand how to get <a href="https://p5js.org/">p5.js</a> working in nikola. It's been a while since I tried and I just want to see if I remember how. This uses the random walk example from Daniel Schiffman's book <i>the Nature of Code</i>.</p>
</div>
</div>
<div class="outline-2" id="outline-container-org3d7a5b6">
<h2 id="org3d7a5b6">Middle</h2>
<div class="outline-text-2" id="text-org3d7a5b6"></div>
<div class="outline-3" id="outline-container-org5a3f18e">
<h3 id="org5a3f18e">A Div to Locate the Sketch</h3>
<div class="outline-text-3" id="text-org5a3f18e">
<p>The id of this div is set in the <code>p5.js</code> <code>setup</code> function as the parent of the sketch.</p>
<div class="highlight">
<pre><span></span>&lt;script language="javascript" type="text/javascript" src="walker.js"&gt;&lt;/script&gt;
&lt;div id="random-walk-container"&gt;
&lt;/div&gt;
</pre></div>
<script language="javascript" src="posts/nature-of-code/a-random-walker/walker.js" type="text/javascript"></script>
<div id="random-walk-container"></div>
<p><b>Note:</b> Originally this wasn't working, because I had the line to include the javascript inside the <code>div</code> to hold the canvas. Make sure that <code>div</code> is always empty.</p>
</div>
</div>
<div class="outline-3" id="outline-container-org7d41e77">
<h3 id="org7d41e77">The Javascript</h3>
<div class="outline-text-3" id="text-org7d41e77">
<div class="highlight">
<pre><span></span>let sketch = function(p) {
    p.setup = function() {
        let parent_div_id = "random-walk-container";
        this.canvas = p.createCanvas($("#" + parent_div_id).outerWidth(true), 300);
        this.canvas.parent();
        p.walker = new Walker(p);
    }

    p.draw = function() {
        p.background(255);
        p.walker.walk();
        p.walker.display();
    }
};

function Walker(p) {
  this.x = p.width/2;
  this.y = p.height/2;

  this.walk = function() {
    this.x = this.x + p.random(-1, 1) * 10;
    this.y = this.y + p.random(-1, 1) * 10;
  }

  this.display = function() {
    p.fill(0);
    p.ellipse(this.x, this.y, 48, 48);
  }
}

//let node = document.getElementById("random-walk")
//window.document.getElementsByTagName("body")[0].appendChild(node);
sketch_container = new p5(sketch, 'random-walk-container');
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-orgfb4bb0c">
<h2 id="orgfb4bb0c">End</h2>
<div class="outline-text-2" id="text-orgfb4bb0c">
<p>As always, this was way harder than it should have been.</p>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="posts/notes/the-origin-of-bayes-theorem/">The Origin of Bayes Theorem</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="posts/notes/the-origin-of-bayes-theorem/" rel="bookmark"><time class="published dt-published" datetime="2019-05-12T14:02:18-07:00" itemprop="datePublished" title="2019-05-12 14:02">2019-05-12 14:02</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="posts/notes/the-origin-of-bayes-theorem/#org2ffff4c">A Brief Sketch of The Timelines to Bayes' Theorem</a></li>
<li><a href="posts/notes/the-origin-of-bayes-theorem/#org37313d1">The Equations</a>
<ul>
<li><a href="posts/notes/the-origin-of-bayes-theorem/#org10aff08">Bayes' Formulation</a></li>
<li><a href="posts/notes/the-origin-of-bayes-theorem/#orgee6afa6">Laplace's First Version</a></li>
<li><a href="posts/notes/the-origin-of-bayes-theorem/#org19fb7e8">Laplace's Final Version</a></li>
</ul>
</li>
<li><a href="posts/notes/the-origin-of-bayes-theorem/#org9ca7d49">Sources</a></li>
</ul>
</div>
</div>
<p>I'm reading "The theory that would not die" and these are notes I took from them. The book didn't really give me a clear idea about what Price's argument was so I also read a <a href="https://qz.com/1315731/the-most-important-formula-in-data-science-was-first-used-to-prove-the-existence-of-god/">Quartz</a> article about that part of the story and, of course, Wikipedia came into it at some points.</p>
<div class="outline-2" id="outline-container-org2ffff4c">
<h2 id="org2ffff4c">A Brief Sketch of The Timelines to Bayes' Theorem</h2>
<div class="outline-text-2" id="text-org2ffff4c">
<ul class="org-ul">
<li>1718: <a href="https://www.wikiwand.com/en/Abraham_de_Moivre">Abraham de Moivre</a> publishes <a href="https://www.wikiwand.com/en/The_Doctrine_of_Chances">The Doctrine of Chances</a>, the first textbook on probability.</li>
<li>1746-1749: Somewhere in this period <a href="https://www.wikiwand.com/en/Thomas_Bayes">Thomas Bayes</a> comes writes <a href="https://www.wikiwand.com/en/An_Essay_towards_solving_a_Problem_in_the_Doctrine_of_Chances">An Essay towards solving a Problem in the Doctrine of the Chances</a> which describes elements of Inverse Probability, in which the probability of a cause is calculated based on observed effects, stated as a thought experiment in which a person turned away from a table estimates the position of a ball based on being told whether subsequent balls randomly dropped on the same table are to the left or the right of it.</li>
<li>1748: <a href="https://www.wikiwand.com/en/David_Hume">David Hume</a> publishes <a href="https://www.wikiwand.com/en/Of_Miracles">Of Miracles</a>, in which he argues that since miracles are, by nature, singular, they can never have as much evidence in their favor as against them.</li>
<li>1749: <a href="https://www.wikiwand.com/en/Pierre-Simon_Laplace">Pierre-Simon Laplace</a> is born</li>
<li>1764: <a href="https://www.wikiwand.com/en/Richard_Price">Richard Price</a> publishes <a href="https://www.wikiwand.com/en/An_Essay_towards_solving_a_Problem_in_the_Doctrine_of_Chances">An Essay towards solving a Problem in the Doctrine of the Chances</a> with his additions, believing that it could act as a refutation of Hume's argument</li>
<li>1774: Laplace comes up with idea that the probability of a cause given the observed effect is the ratio of the probability of that effect given the cause to sum of the probabilities for all other causes given that effect.</li>
<li>1781: Price tells <a href="https://www.wikiwand.com/en/Marquis_de_Condorcet">the Marquis of Condorcet</a> about Bayes' work and Laplace incorporates the use of the prior into his formulation</li>
<li>1810: Laplace discovers <a href="https://www.wikiwand.com/en/Central_limit_theorem">the Central Limit Theorem</a></li>
<li>1814: Laplace extends his version of Bayes' equation</li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org37313d1">
<h2 id="org37313d1">The Equations</h2>
<div class="outline-text-2" id="text-org37313d1">
<p>Since it's hard to write out the equations in bullet points I'm going to write some simple versions here.</p>
</div>
<div class="outline-3" id="outline-container-org10aff08">
<h3 id="org10aff08">Bayes' Formulation</h3>
<div class="outline-text-3" id="text-org10aff08">
<p>"The theory that would not die" notes that Bayes' didn't write out an equation, but it can be written out something like this. \[ P(\textit{cause}|\textit{effect}) = \frac{P(\textit{effect}|\textit{cause}) P(\textit{cause})}{P(\textit{effect})} \]</p>
</div>
</div>
<div class="outline-3" id="outline-container-orgee6afa6">
<h3 id="orgee6afa6">Laplace's First Version</h3>
<div class="outline-text-3" id="text-orgee6afa6">
<p>Originally Laplace didn't have the prior's in his equation (I'll substitute <i>C</i> for <i>cause</i>, <i>E</i> for <i>effect</i> and <i>C'</i> for not our theorized cause). \[ P(C|E) = \frac{P(E|C)}{\sum P(E|C')} \]</p>
</div>
</div>
<div class="outline-3" id="outline-container-org19fb7e8">
<h3 id="org19fb7e8">Laplace's Final Version</h3>
<div class="outline-text-3" id="text-org19fb7e8">
<p>\[ P(C|E) = \frac{P(E|C)P_{\textit{prior}}(C)}{\sum P(E|C') P_{\textit{prior}} (C')} \]</p>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org9ca7d49">
<h2 id="org9ca7d49">Sources</h2>
<div class="outline-text-2" id="text-org9ca7d49">
<ol class="org-ol">
<li>McGrayne SB. The theory that would not die: how Bayes’ rule cracked the enigma code, hunted down Russian submarines, and emerged triumphant from two centuries of controversy. paperback ed. New Haven, Conn.: Yale University Press; 2011. 336 p.</li>
<li>Kopf D. The most important formula in data science was first used to prove the existence of God [Internet]. Quartz. [cited 2019 May 12]. Available from: <a href="https://qz.com/1315731/the-most-important-formula-in-data-science-was-first-used-to-prove-the-existence-of-god/">https://qz.com/1315731/the-most-important-formula-in-data-science-was-first-used-to-prove-the-existence-of-god/</a></li>
</ol>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="posts/networks/looking-at-random-graphs/">Looking at random graphs</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="posts/networks/looking-at-random-graphs/" rel="bookmark"><time class="published dt-published" datetime="2019-04-13T11:59:44-07:00" itemprop="datePublished" title="2019-04-13 11:59">2019-04-13 11:59</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="posts/networks/looking-at-random-graphs/#org1b898cf">Imports</a></li>
<li><a href="posts/networks/looking-at-random-graphs/#org74a2156">Part 1 - Random Graph Identification</a>
<ul>
<li><a href="posts/networks/looking-at-random-graphs/#orgc3de31c">Load the data</a></li>
<li><a href="posts/networks/looking-at-random-graphs/#orged95f0b">Graph Identification</a></li>
</ul>
</li>
<li><a href="posts/networks/looking-at-random-graphs/#orgc875065">Part 2 - Company Emails</a>
<ul>
<li><a href="posts/networks/looking-at-random-graphs/#org6e75e0f">Part 2A - Salary Prediction</a></li>
<li><a href="posts/networks/looking-at-random-graphs/#org55cad8d">Part 2B - New Connections Prediction</a></li>
<li><a href="posts/networks/looking-at-random-graphs/#orgb3ef176">Separate the Target and Training Sets</a></li>
<li><a href="posts/networks/looking-at-random-graphs/#orgad08b9a">Scaling the Data</a></li>
<li><a href="posts/networks/looking-at-random-graphs/#org8ac5901">Feature Selection</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org1b898cf">
<h2 id="org1b898cf">Imports</h2>
<div class="outline-text-2" id="text-org1b898cf">
<div class="highlight">
<pre><span></span># python standard library
import os
import pickle

# from pypi
import networkx
import numpy
import pandas

from sklearn.linear_model import LogisticRegressionCV
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import (
    ExtraTreesClassifier,
    RandomForestClassifier,
    )
from sklearn.feature_selection import (
    RFECV,
    SelectFromModel,
)
from sklearn.model_selection import (
    GridSearchCV,
    StratifiedKFold,
    train_test_split,
    )
</pre></div>
<div class="highlight">
<pre><span></span>% matplotlib inline
</pre></div>
</div>
</div>
<div class="outline-2" id="outline-container-org74a2156">
<h2 id="org74a2156">Part 1 - Random Graph Identification</h2>
<div class="outline-text-2" id="text-org74a2156">
<p>For the first part of this assignment you will analyze randomly generated graphs and determine which algorithm created them.</p>
</div>
<div class="outline-3" id="outline-container-orgc3de31c">
<h3 id="orgc3de31c">Load the data</h3>
<div class="outline-text-3" id="text-orgc3de31c">
<div class="highlight">
<pre><span></span>part_one_graphs = pickle.load(open('A4_graphs','rb'))
print(len(part_one_graphs))
print(type(part_one_graphs[0]))
</pre></div>
<p><code>part_one_graphs</code> is a list containing 5 networkx graphs. Each of these graphs were generated by one of three possible algorithms:</p>
<ul class="org-ul">
<li>Preferential Attachment (`'PA'`)</li>
<li>Small World with low probability of rewiring (`'SW<sub>L</sub>'`)</li>
<li>Small World with high probability of rewiring (`'SW<sub>H</sub>'`)</li>
</ul>
<p>Analyze each of the 5 graphs and determine which of the three algorithms generated the graph.</p>
<p><b>The `graph<sub>identification</sub>` function should return a list of length 5 where each element in the list is either `'PA'`, `'SW<sub>L</sub>'`, or `'SW<sub>H</sub>'`.</b></p>
</div>
</div>
<div class="outline-3" id="outline-container-orged95f0b">
<h3 id="orged95f0b">Graph Identification</h3>
<div class="outline-text-3" id="text-orged95f0b">
<div class="highlight">
<pre><span></span>def graph_identification():
    """Identifies the type of graph each of the graphs is

    Returns:
     list: string identifiers for the type of graph
    """
    graph_types = []
    for graph in part_one_graphs:
        path = networkx.average_shortest_path_length(graph)
        coefficient = networkx.average_clustering(graph)
        if path &gt; 6:
            if coefficient &lt; 0.5:
                graph_types.append("SW_L")
            else:
                raise Exception("unexpected type")
        else:
            if coefficient &lt; 0.5:
                graph_types.append("PA")
            else:
                graph_types.append("SW_H")
    return graph_types
</pre></div>
<p>This was marked wrong by the grader.</p>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-orgc875065">
<h2 id="orgc875065">Part 2 - Company Emails</h2>
<div class="outline-text-2" id="text-orgc875065">
<p>For the second part of this assignment you will be working with a company's email network where each node corresponds to a person at the company, and each edge indicates that at least one email has been sent between two people.</p>
<p>The network also contains the node attributes `Department` and `ManagementSalary`.</p>
<p>`Department` indicates the department in the company which the person belongs to, and `ManagementSalary` indicates whether that person is receiving a managment position salary.</p>
<div class="highlight">
<pre><span></span>email = networkx.read_gpickle('email_prediction.txt')
print(networkx.info(email))
</pre></div>
</div>
<div class="outline-3" id="outline-container-org6e75e0f">
<h3 id="org6e75e0f">Part 2A - Salary Prediction</h3>
<div class="outline-text-3" id="text-org6e75e0f">
<p>Using network `email`, identify the people in the network with missing values for the node attribute `ManagementSalary` and predict whether or not these individuals are receiving a managment position salary.</p>
<p>To accomplish this, you will need to create a matrix of node features using networkx, train a sklearn classifier on nodes that have `ManagementSalary` data, and predict a probability of the node receiving a managment salary for nodes where `ManagementSalary` is missing.</p>
<p>Your predictions will need to be given as the probability that the corresponding employee is receiving a managment position salary.</p>
<p>The evaluation metric for this assignment is the Area Under the ROC Curve (AUC).</p>
<p>Your grade will be based on the AUC score computed for your classifier. A model which with an AUC of 0.75 or higher will receive full points.</p>
<p>Using your trained classifier, return a series of length 252 with the data being the probability of receiving managment salary, and the index being the node id.</p>
<pre class="example">
1       1.0
2       0.0
5       0.8
8       1.0
    ...
996     0.7
1000    0.5
1001    0.0
Length: 252, dtype: float64
</pre></div>
<div class="outline-4" id="outline-container-org233ab2e">
<h4 id="org233ab2e">The Data Frame</h4>
<div class="outline-text-4" id="text-org233ab2e">
<div class="highlight">
<pre><span></span>if not os.path.isfile("email_data.h5"):
    data = pandas.DataFrame(index=email.nodes())
    data["department"] = pandas.Series(networkx.get_node_attributes(email, "Department"))
    data["management"] = pandas.Series(networkx.get_node_attributes(email, "ManagementSalary"))
    data["clustering"] = pandas.Series(networkx.clustering(email))
    data["degree"] = pandas.Series(email.degree())
    data["degree_centrality"] = pandas.Series(networkx.degree_centrality(email))
    data["closeness_centrality"] = pandas.Series(networkx.closeness_centrality(email))
    data["betweenness_centrality"] = pandas.Series(networkx.betweenness_centrality(email))
    data["pagerank"] = pandas.Series(networkx.pagerank(email))
    _, authority = networkx.hits(email)
    data["authority"] = pandas.Series(authority)
    data.to_hdf("email_data.h5","df" )
else:
    data = pandas.read_hdf('email_data.h5', "df")
print(data.head())    
</pre></div>
<div class="highlight">
<pre><span></span>print(data.management.unique())
print(data.department.unique())
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org4e3aa18">
<h4 id="org4e3aa18">Department Dummy Variables</h4>
<div class="outline-text-4" id="text-org4e3aa18">
<p>Even though I don't think it's going to prove useful, the <code>department</code> feature is actually categorical, despite the use of integers so we'll have to use One-Hot-Encoding to add dummy variables for it.</p>
<div class="highlight">
<pre><span></span>dummies_data = pandas.get_dummies(data, columns=["department"])
print(dummies_data.head(1))
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org62645a2">
<h4 id="org62645a2">Separating the Training and Prediction Sets</h4>
<div class="outline-text-4" id="text-org62645a2">
<p>We're going to use the model to predict what the missing <code>management</code> values are so I'm going to separate the missing and non-missing sets.</p>
<div class="highlight">
<pre><span></span>training_data = dummies_data[pandas.notnull(dummies_data.management)]
prediction_data = dummies_data[pandas.isnull(dummies_data.management)]
print(training_data.shape)
print(prediction_data.shape)
</pre></div>
<p>The problem description tells us that the answer should have 252 entries so this is a safe assertion.</p>
<div class="highlight">
<pre><span></span>assert len(prediction_data) == 252
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org8500437">
<h4 id="org8500437">Training and Target Data</h4>
<div class="outline-text-4" id="text-org8500437">
<p>To train the model we'll need to separate out the <code>management</code> column (and remove it entirely from the <code>prediction</code> set).</p>
<div class="highlight">
<pre><span></span>non_management = [column for column in training_data.columns if column != "management"]
y_train = training_data.management
x_train = training_data[non_management]
x_predict = prediction_data[non_management]
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org68cbaf5">
<h4 id="org68cbaf5">Scaling</h4>
<div class="outline-text-4" id="text-org68cbaf5">
<p>I don't think the Random Forest model that I'm going to use needs it, but I'm going to standardize the data.</p>
<div class="highlight">
<pre><span></span>scaler = StandardScaler()
x_train = scaler.fit_transform(x_train)
x_predict = pandas.DataFrame(scaler.transform(x_predict), index=x_predict.index)
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org1a136ba">
<h4 id="org1a136ba">Feature Selection</h4>
<div class="outline-text-4" id="text-org1a136ba">
<p>Since we now have so many features, I'm going to do some feature selection.</p>
<div class="highlight">
<pre><span></span>print(x_train.shape)
print(x_predict.shape)
trees = ExtraTreesClassifier(n_estimators=10)
eliminator = RFECV(estimator=trees, cv=StratifiedKFold(10), scoring="roc_auc")
eliminator.fit(x_train, y_train)
x_train_reduced = eliminator.transform(x_train)
x_predict_reduced = pandas.DataFrame(eliminator.transform(x_predict), index=x_predict.index)
print(x_train_reduced.shape)
print(x_predict_reduced.shape)
</pre></div>
<p>When I used the train-test-split training model it left 17 columns. I wonder if using the whole training set messes it up.</p>
</div>
</div>
<div class="outline-4" id="outline-container-org671a17a">
<h4 id="org671a17a">Logistic Regression</h4>
<div class="outline-text-4" id="text-org671a17a">
<div class="highlight">
<pre><span></span>model = LogisticRegressionCV(penalty="l1", scoring="roc_auc",
                             solver="liblinear", cv=StratifiedKFold(10))
model.fit(x_train_reduced, y_train)
print(model.scores_[1.0].mean())
print(model.scores_[1.0].std())
</pre></div>
<p>It seems to be doing much worse than when I used the train-test split.</p>
</div>
</div>
<div class="outline-4" id="outline-container-orgf4a25a4">
<h4 id="orgf4a25a4">Random Forests</h4>
<div class="outline-text-4" id="text-orgf4a25a4">
<div class="highlight">
<pre><span></span>parameter_grid = dict(n_estimators=range(10, 100, 10))
search = GridSearchCV(RandomForestClassifier(), parameter_grid,
                      cv=StratifiedKFold(10), scoring="roc_auc")
search.fit(x_train_reduced, y_train)
print(search.best_score_)
</pre></div>
<div class="highlight">
<pre><span></span>class RandomForest(object):
    """builds the random forest

    Args:
     x_train(array): data to train on
     y_train(array): targets for training
     start (int): start value for number of estimators
     stop (int): upper value for range of estimators
     step (int): increment for range of estimators
     folds (int): K-folds for cross-validation    
    """
    def __init__(self, x_train, y_train,
                 start=10, stop=100, step=10, folds=10):
        self.x_train = x_train
        self.y_train = y_train
        self.start = start
        self.stop = stop
        self.step = step
        self.folds = folds
        self._parameters = None
        self._search = None
        self._model = None
        return

    @property
    def parameters(self):
        """parameters for the grid-search"""
        if self._parameters is None:
            self._parameters = dict(n_estimators=range(self.start,
                                                       self.stop,
                                                       self.step))
        return self._parameters

    @property
    def search(self):
        """fitted grid search to find hyper-parameters"""
        if self._search is None:
            self._search = GridSearchCV(RandomForestClassifier(),
                                        self.parameters,
                                        cv=StratifiedKFold(self.folds),
                                        scoring="roc_auc")
            self._search.fit(self.x_train, self.y_train)
        return self._search

    @property
    def model(self):
        """best model found by the grid search"""
        if self._model is None:
            self._model = self.search.best_estimator_
        return self._model
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org139c2a7">
<h4 id="org139c2a7">Data Loader</h4>
<div class="outline-text-4" id="text-org139c2a7">
<p>Since having all these org-babel things around makes things kind of hard I'm going to make a class to bundle everything together.</p>
<div class="highlight">
<pre><span></span>class DataLoader(object):
    """loads and transforms the data
    Args:
     estimators (int): number of trees to use for feature elimination
    """
    def __init__(self, estimators=10):
        self.estimators = estimators
        self._data = None
        self._dummies_data = None
        self._training_data = None
        self._prediction_data = None
        self._non_management = None
        self._y_train = None
        self._x_train = None
        self._x_predict = None
        self._scaler = None
        self._x_train_scaled = None
        self._x_predict_scaled = None
        self._eliminator = None
        self._x_train_reduced = None
        self._x_predict_reduced = None
        return

    @property
    def data(self):
        """The initial data"""
        if self._data is None:
            if not os.path.isfile("email_data.h5"):
                data = pandas.DataFrame(index=email.nodes())
                data["department"] = pandas.Series(networkx.get_node_attributes(email, "Department"))
                data["management"] = pandas.Series(networkx.get_node_attributes(email, "ManagementSalary"))
                data["clustering"] = pandas.Series(networkx.clustering(email))
                data["degree"] = pandas.Series(email.degree())
                data["degree_centrality"] = pandas.Series(networkx.degree_centrality(email))
                data["closeness_centrality"] = pandas.Series(networkx.closeness_centrality(email))
                data["betweenness_centrality"] = pandas.Series(networkx.betweenness_centrality(email))
                data["pagerank"] = pandas.Series(networkx.pagerank(email))
                _, authority = networkx.hits(email)
                data["authority"] = pandas.Series(authority)
                data.to_hdf("email_data.h5","df" )
                self._data = data
            else:
                self._data = pandas.read_hdf('email_data.h5', "df")
        return self._data

    @property
    def dummies_data(self):
        """one-hot-encoded data"""
        if self._dummies_data is None:
            self._dummies_data = pandas.get_dummies(self.data, columns=["department"])
        return self._dummies_data

    @property
    def training_data(self):
        """data with management information"""
        if self._training_data is None:
            self._training_data = self.dummies_data[pandas.notnull(
                self.dummies_data.management)]
        return self._training_data

    @property
    def prediction_data(self):
        """data missing management information"""
        if self._prediction_data is None:
            self._prediction_data = self.dummies_data[pandas.isnull(
                self.dummies_data.management)]
            assert len(self._prediction_data) == 252
        return self._prediction_data

    @property
    def non_management(self):
        """list of columns minus management"""
        if self._non_management is None:
            self._non_management = [
                column for column in self.training_data.columns
                if column != "management"]
        return self._non_management

    @property
    def y_train(self):
        """target-data for training"""
        if self._y_train is None:
            self._y_train = self.training_data.management
        return self._y_train

    @property
    def x_train(self):
        """data for training"""
        if self._x_train is None:
            self._x_train = self.training_data[self.non_management]
        return self._x_train

    @property
    def x_predict(self):
        """set to make predictions"""
        if self._x_predict is None:
            self._x_predict = self.prediction_data[self.non_management]
        return self._x_predict

    @property
    def scaler(self):
        """standard scaler"""
        if self._scaler is None:
            self._scaler = StandardScaler()
        return self._scaler

    @property
    def x_train_scaled(self):
        """training data scaled to 1 std, 0 mean"""
        if self._x_train_scaled is None:
            self._x_train_scaled = self.scaler.fit_transform(self.x_train)
        return self._x_train_scaled

    @property
    def x_predict_scaled(self):
        """prediction data with mean 0, std 1

        The answer requires the index so this is a dataframe
        instead of an array

        Returns:
         pandas.DataFrame: scaled data with index preserved
        """
        if self._x_predict_scaled is None:
            self._x_predict_scaled = pandas.DataFrame(
                self.scaler.transform(self.x_predict),
                index=self.x_predict.index)
        return self._x_predict_scaled

    @property
    def eliminator(self):
        """recursive feature eliminator"""
        if self._eliminator is None:
            trees = ExtraTreesClassifier(n_estimators=10)
            self._eliminator = RFECV(estimator=trees, cv=StratifiedKFold(10), 
                                     scoring="roc_auc")
            self._eliminator.fit(self.x_train_scaled, self.y_train)
        return self._eliminator

    @property
    def x_train_reduced(self):
        """training data with features eliminated"""
        if self._x_train_reduced is None:
            self._x_train_reduced = self.eliminator.transform(
                self.x_train_scaled)
        return self._x_train_reduced

    @property
    def x_predict_reduced(self):
        """prediction data with features eliminated"""
        if self._x_predict_reduced is None:
            self._x_predict_reduced = pandas.DataFrame(
                self.eliminator.transform(self.x_predict_scaled),
                index=self.x_predict_scaled.index)
        return self._x_predict_reduced
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org05e74ea">
<h4 id="org05e74ea">Submission</h4>
<div class="outline-text-4" id="text-org05e74ea">
<div class="highlight">
<pre><span></span>def salary_predictions():
    """Prediction that employee is management

    Calculates the probability that an employee is management

    Returns:
     pandas.Series: Node ID, probability of node
    """
    data = DataLoader()
    forest = RandomForest(data.x_train_reduced, data.y_train)
    # probabilites is an array with rows of 
    # [&lt;probability not management&gt;, &lt;probability management&gt;]
    # see forest.model.classes_ to see what each entry represents
    probabilities = forest.model.predict_proba(data.x_predict_reduced)
    return pandas.Series(probabilities[:, 1], index=data.x_predict_reduced.index)
</pre></div>
<div class="highlight">
<pre><span></span>output = salary_predictions()
print(output.head())
</pre></div>
<div class="highlight">
<pre><span></span>assert all(output.index == DataLoader().prediction_data.index)
assert len(output) == 252
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-org55cad8d">
<h3 id="org55cad8d">Part 2B - New Connections Prediction</h3>
<div class="outline-text-3" id="text-org55cad8d">
<p>For the last part of this assignment, you will predict future connections between employees of the network. The future connections information has been loaded into the variable `future<sub>connections</sub>`. The index is a tuple indicating a pair of nodes that currently do not have a connection, and the `Future Connection` column indicates if an edge between those two nodes will exist in the future, where a value of 1.0 indicates a future connection.</p>
<div class="highlight">
<pre><span></span>future_connections = pandas.read_csv('Future_Connections.csv', index_col=0, converters={0: eval})
</pre></div>
<div class="highlight">
<pre><span></span>print(future_connections.head(10))
</pre></div>
<div class="highlight">
<pre><span></span>print(future_connections['Future Connection'].value_counts())
</pre></div>
<p>Using network `G` and `future<sub>connections</sub>`, identify the edges in `future<sub>connections</sub>` with missing values and predict whether or not these edges will have a future connection.</p>
<p>To accomplish this, you will need to create a matrix of features for the edges found in `future<sub>connections</sub>` using networkx, train a sklearn classifier on those edges in `future<sub>connections</sub>` that have `Future Connection` data, and predict a probability of the edge being a future connection for those edges in `future<sub>connections</sub>` where `Future Connection` is missing.</p>
<p>Your predictions will need to be given as the probability of the corresponding edge being a future connection.</p>
<p>The evaluation metric for this assignment is the Area Under the ROC Curve (AUC).</p>
<p>Your grade will be based on the AUC score computed for your classifier. A model which with an AUC of 0.75 or higher will receive full points.</p>
<p>Using your trained classifier, return a series of length 122112 with the data being the probability of the edge being a future connection, and the index being the edge as represented by a tuple of nodes.</p>
<pre class="example">
(107, 348)    0.35
(542, 751)    0.40
(20, 426)     0.55
(50, 989)     0.35
          ...
(939, 940)    0.15
(555, 905)    0.35
(75, 101)     0.65
Length: 122112, dtype: float64
</pre></div>
<div class="outline-4" id="outline-container-orgdefe904">
<h4 id="orgdefe904">Add Network Features</h4>
<div class="outline-text-4" id="text-orgdefe904">
<div class="highlight">
<pre><span></span>class Futures(object):
    target = "Future Connection"
    data_file = "Future_Connections.csv"
    graph_file = "email_prediction.txt"
    networkx_data_index = 2
    folds = 10
</pre></div>
<div class="highlight">
<pre><span></span>class DataNames(object):
    resource_allocation = 'resource_allocation'
    jaccard = 'jaccard_coefficient'
    adamic = "adamic_adar"
    preferential = "preferential_attachment"
</pre></div>
<div class="highlight">
<pre><span></span>def add_networkx_data(adder, name, graph=email, frame=future_connections):
    """Adds networkx data to the frame

    The networkx link-prediction functions return generators of triples:
     (first-node, second-node, value)

    This will use the index of the frame that's passed in as the source of 
    node-pairs for the networkx function (called `ebunch` in the networkx
    documentation) and the add only the value we want back to the frame

    Args:
     adder: networkx function to call to get the new data
     name: column-name to add to the frame
     graph: networkx graph to pass to the function
     frame (pandas.DataFrame): frame with node-pairs as index to add data to
    """
    frame[name] = [output[Futures.networkx_data_index]
                   for output in adder(graph, frame.index)]
    return frame
</pre></div>
</div>
<div class="outline-5" id="outline-container-orgc4ca998">
<h5 id="orgc4ca998">Adding A Resource Allocation Index</h5>
<div class="outline-text-5" id="text-orgc4ca998">
<div class="highlight">
<pre><span></span>add_networkx_data(networkx.resource_allocation_index,
                  DataNames.resource_allocation)
</pre></div>
<div class="highlight">
<pre><span></span>print(future_connections.head(1))
</pre></div>
</div>
</div>
<div class="outline-5" id="outline-container-org58f379f">
<h5 id="org58f379f">Adding the Jaccard Coefficient</h5>
<div class="outline-text-5" id="text-org58f379f">
<div class="highlight">
<pre><span></span>add_networkx_data(networkx.jaccard_coefficient, DataNames.jaccard)
</pre></div>
<div class="highlight">
<pre><span></span>print(future_connections.head(1))
</pre></div>
</div>
</div>
<div class="outline-5" id="outline-container-org92d86da">
<h5 id="org92d86da">Adamic Adar</h5>
<div class="outline-text-5" id="text-org92d86da">
<div class="highlight">
<pre><span></span>add_networkx_data(networkx.adamic_adar_index, DataNames.adamic)
</pre></div>
<div class="highlight">
<pre><span></span>print(future_connections.head(1))
</pre></div>
</div>
</div>
<div class="outline-5" id="outline-container-org3e4025c">
<h5 id="org3e4025c">Preferential Attachment</h5>
<div class="outline-text-5" id="text-org3e4025c">
<div class="highlight">
<pre><span></span>add_networkx_data(networkx.preferential_attachment, DataNames.preferential)
</pre></div>
<div class="highlight">
<pre><span></span>print(future_connections.head(1))
</pre></div>
</div>
</div>
</div>
<div class="outline-4" id="outline-container-orgc16d60b">
<h4 id="orgc16d60b">Setup the Training and Testing Data</h4>
<div class="outline-text-4" id="text-orgc16d60b"></div>
<div class="outline-5" id="outline-container-org1c3a250">
<h5 id="org1c3a250">Separating the Edges Without 'Future Connection' Values</h5>
<div class="outline-text-5" id="text-org1c3a250">
<p>We are going to train on the values in the data with predictions and then make predictions for those that don't.</p>
<div class="highlight">
<pre><span></span>prediction_set = future_connections[future_connections[Futures.target].isnull()]
training_set = future_connections[future_connections[Futures.target].notnull()]
</pre></div>
<div class="highlight">
<pre><span></span>print(prediction_set.shape)
print(training_set.shape)
assert len(prediction_set) + len(training_set) == len(future_connections)
</pre></div>
</div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-orgb3ef176">
<h3 id="orgb3ef176">Separate the Target and Training Sets</h3>
<div class="outline-text-3" id="text-orgb3ef176">
<div class="highlight">
<pre><span></span>non_target = [column for column in future_connections.columns
              if column != Futures.target]
x_train = training_set[non_target]
y_train = training_set[Futures.target]
x_predict = prediction_set[non_target]
</pre></div>
<div class="highlight">
<pre><span></span>assert all(x_train.columns == x_predict.columns)
assert len(x_train) == len(x_test)
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-orgad08b9a">
<h3 id="orgad08b9a">Scaling the Data</h3>
<div class="outline-text-3" id="text-orgad08b9a">
<p>To enable the use of linear models I'm going to scale the data so the mean is 0 and the variance is 1.</p>
<div class="highlight">
<pre><span></span>scaler = StandardScaler()
x_train_scaled = scaler.fit_transform(x_train)
x_predict_scaled = scaler.transform(x_predict)

x_train_frame = pandas.DataFrame(x_train_scaled, columns=x_train.columns)
x_predict_frame = pandas.DataFrame(x_predict_scaled, columns=x_predict.columns)
</pre></div>
<div class="highlight">
<pre><span></span>print(training.describe())
print(predictions.describe())
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org8ac5901">
<h3 id="org8ac5901">Feature Selection</h3>
<div class="outline-text-3" id="text-org8ac5901">
<p>To reduce the dimensionality I'm going to use model-based selection with Extra Trees.</p>
<div class="highlight">
<pre><span></span>estimator = ExtraTreesClassifier()
estimator.fit(x_train_scaled, y_train)
selector = SelectFromModel(estimator, prefit=True)
x_train_trees_sfm = selector.transform(x_train_scaled)
x_predict_sfm = selector.transform(x_predict_scaled)
print(estimator.feature_importances_)
</pre></div>
<div class="highlight">
<pre><span></span>print(x_train_trees_sfm.shape)
</pre></div>
</div>
<div class="outline-4" id="outline-container-org46db689">
<h4 id="org46db689">Missing Future Connections</h4>
<div class="outline-text-4" id="text-org46db689">
<div class="highlight">
<pre><span></span>model = LogisticRegressionCV(n_jobs=-1, scoring='roc_auc', solver='liblinear',
                             cv=StratifiedKFold())
model.fit(x_train_trees_sfm, y_train)
</pre></div>
<div class="highlight">
<pre><span></span>for scores in model.scores_[1.0]:
    print(max(scores))
</pre></div>
<div class="highlight">
<pre><span></span>print(model.classes_)
</pre></div>
<div class="highlight">
<pre><span></span>def new_connections_predictions():    
    probabilities = model.predict_proba(x_predict_sfm)
    return pandas.Series(probabilities[:, 1], index=prediction_set.index)
</pre></div>
<div class="highlight">
<pre><span></span>outcome = new_connections_predictions()
assert len(outcome) == 122112, len(outcome)
print(outcome.head())
</pre></div>
</div>
</div>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="posts/networks/selecting-the-e-mail-model/">Selecting the E-Mail Model</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="posts/networks/selecting-the-e-mail-model/" rel="bookmark"><time class="published dt-published" datetime="2019-04-13T11:57:42-07:00" itemprop="datePublished" title="2019-04-13 11:57">2019-04-13 11:57</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="posts/networks/selecting-the-e-mail-model/#orgcdd8d54">Imports</a></li>
<li><a href="posts/networks/selecting-the-e-mail-model/#orgf09d04e">The Data</a>
<ul>
<li><a href="posts/networks/selecting-the-e-mail-model/#org88f1e4e">Department</a></li>
<li><a href="posts/networks/selecting-the-e-mail-model/#org1bd3f86">Splitting the Data</a></li>
</ul>
</li>
<li><a href="posts/networks/selecting-the-e-mail-model/#org18d22e8">Standardizing the Data</a></li>
<li><a href="posts/networks/selecting-the-e-mail-model/#org84a74ef">Dummy Classifier</a></li>
<li><a href="posts/networks/selecting-the-e-mail-model/#org81344d2">Feature Selection</a></li>
<li><a href="posts/networks/selecting-the-e-mail-model/#org19ffe46">Fit and Display</a></li>
<li><a href="posts/networks/selecting-the-e-mail-model/#orgd6ee56a">Logistic Regression</a>
<ul>
<li><a href="posts/networks/selecting-the-e-mail-model/#org200e4fd">L1 Penalty</a></li>
</ul>
</li>
<li><a href="posts/networks/selecting-the-e-mail-model/#org78c87a6">Random Forests</a></li>
<li><a href="posts/networks/selecting-the-e-mail-model/#orgb2e286f">K Nearest Neighbors</a></li>
<li><a href="posts/networks/selecting-the-e-mail-model/#orgf78b53b">Support Vector Classifier (SVC)</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-orgcdd8d54">
<h2 id="orgcdd8d54">Imports</h2>
<div class="outline-text-2" id="text-orgcdd8d54">
<div class="highlight">
<pre><span></span># pypi
from sklearn.ensemble import (
    ExtraTreesClassifier,
    RandomForestClassifier,
    )
from sklearn.feature_selection import (
    RFECV,
    SelectFromModel,
)
from sklearn.linear_model import LogisticRegressionCV
from sklearn.model_selection import (
    GridSearchCV,
    StratifiedKFold,
    train_test_split,
    )

from sklearn.dummy import DummyClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.preprocessing import StandardScaler
from sklearn.svm import SVC
import matplotlib.pyplot as pyplot
import mglearn
import numpy
import pandas
import seaborn
</pre></div>
<div class="highlight">
<pre><span></span>% matplotlib inline
seaborn.set_style("whitegrid")
</pre></div>
</div>
</div>
<div class="outline-2" id="outline-container-orgf09d04e">
<h2 id="orgf09d04e">The Data</h2>
<div class="outline-text-2" id="text-orgf09d04e">
<div class="highlight">
<pre><span></span>data = pandas.read_hdf("email_data.h5", "df")
cleaned_data = data[pandas.notnull(data.management)]
</pre></div>
<div class="highlight">
<pre><span></span>print(cleaned_data.head())
</pre></div>
</div>
<div class="outline-3" id="outline-container-org88f1e4e">
<h3 id="org88f1e4e">Department</h3>
<div class="outline-text-3" id="text-org88f1e4e">
<p>Even though I don't think it's going to prove useful, the <code>department</code> feature is actually categorical, despite the use of integers so we'll have to add dummy variables for it.</p>
<div class="highlight">
<pre><span></span>cleaned_data = pandas.get_dummies(cleaned_data, columns=["department"])
print(cleaned_data.head(1))
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org1bd3f86">
<h3 id="org1bd3f86">Splitting the Data</h3>
<div class="outline-text-3" id="text-org1bd3f86">
<p>For evaluation purposes I'll use the traditional train-test split.</p>
<div class="highlight">
<pre><span></span>x_data = cleaned_data.loc[:, cleaned_data.columns != "management"]

y_data = cleaned_data.management

print(x_data.head())
print(y_data.head())
</pre></div>
<div class="highlight">
<pre><span></span>print(y_data.value_counts())
</pre></div>
<div class="highlight">
<pre><span></span>seaborn.countplot(x='management', data=cleaned_data)
</pre></div>
<p>It looks like the management data is unbalanced, so I'll do a stratified split.</p>
<div class="highlight">
<pre><span></span>x_train, x_test, y_train, y_test = train_test_split(x_data, y_data, stratify=y_data)
print(x_train.shape)
print(y_test.shape)
</pre></div>
<div class="highlight">
<pre><span></span>seaborn.countplot(y_train)
</pre></div>
<p>Looks close enough for government work.</p>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org18d22e8">
<h2 id="org18d22e8">Standardizing the Data</h2>
<div class="outline-text-2" id="text-org18d22e8">
<p>The linear models expect the data to be standardized, so to make the comparisons fair I'll standardize the data first. First, a look at the data before scaling.</p>
<div class="highlight">
<pre><span></span>print(x_train.describe())
</pre></div>
<p>Now I'll scale it.</p>
<div class="highlight">
<pre><span></span>scaler = StandardScaler()
scaler.fit(x_train)
x_train = pandas.DataFrame(scaler.transform(x_train), columns=x_train.columns)
x_test = scaler.transform(x_test)
</pre></div>
<p>Now the means should be near 0 (very small) and the standard deviations should be around 1.</p>
<div class="highlight">
<pre><span></span>print(x_train.describe())
</pre></div>
</div>
</div>
<div class="outline-2" id="outline-container-org84a74ef">
<h2 id="org84a74ef">Dummy Classifier</h2>
<div class="outline-text-2" id="text-org84a74ef">
<p>As a baseline I'll use a <a href="http://scikit-learn.org/stable/modules/model_evaluation.html#dummy-estimators">Dummy Classifier</a> which uses a simple rule rather than the input data to make predictions.</p>
<div class="highlight">
<pre><span></span>parameter_grid = dict(strategy=["stratified", 'most_frequent', 'prior', 'uniform'])
</pre></div>
<p>Now we'll do a grid search.</p>
<div class="highlight">
<pre><span></span>grid_search = GridSearchCV(DummyClassifier(), parameter_grid,
                           cv=StratifiedKFold(10), scoring="roc_auc")
grid_search.fit(x_train, y_train)
</pre></div>
<div class="highlight">
<pre><span></span>BASELINE = grid_search.score(x_test, y_test)
print(grid_search.best_params_)
print(BASELINE)
</pre></div>
<p>It looks like it chose the <b>stratified</b> strategy, which should predict that the instances are all non-managers. Our baseline AUC score is 0.5 (0.47 now?).</p>
<div class="highlight">
<pre><span></span>results = pandas.DataFrame(grid_search.cv_results_)
print(results.head(1))
</pre></div>
<div class="highlight">
<pre><span></span>figure = pyplot.figure()
axe = figure.gca()
strategies = parameter_grid["strategy"]
x = pyplot.xticks(list(range(len(strategies))), strategies)
axe.plot(range(len(strategies)), results.mean_test_score)
axe.set_title("Dummy Classifier Strategy Vs AUC")
axe.set_xlabel("strategy")
axe.set_ylabel("AUC Score")
</pre></div>
<p>So it looks like all the strategies except <b>stratified</b> did the same - and even the stratified did basically the same if you round it off.</p>
</div>
</div>
<div class="outline-2" id="outline-container-org81344d2">
<h2 id="org81344d2">Feature Selection</h2>
<div class="outline-text-2" id="text-org81344d2">
<p>I'm going to need to do some feature reduction, but figuring out what is important and what isn't is something I'm going to have to leave to the machine. I'm going to assume that the features thrown out by logistic regression with l1 penalization are unimportant.</p>
<div class="highlight">
<pre><span></span>logistic_model = LogisticRegressionCV(penalty='l1',
                                      solver='liblinear', scoring="roc_auc")
logistic_model.fit(x_train, y_train)
model = SelectFromModel(logistic_model, prefit=True)

x_train_positive = model.transform(x_train)
x_test_positive = model.transform(x_test)
</pre></div>
<div class="highlight">
<pre><span></span>print(logistic_model.score(x_test, y_test))
</pre></div>
<p>Logistic Regression with <code>L1</code> penalty seems to do reasonably well even without feature selection.</p>
<div class="highlight">
<pre><span></span>logistic_model.fit(x_train_positive, y_train)
print(logistic_model.score(x_test_positive, y_test))
</pre></div>
<p>It looks like feature selection didn't really help here.</p>
<div class="highlight">
<pre><span></span>print(x_train.shape)
print(x_train_positive.shape)
print(model.ranking_)
</pre></div>
<p>As a double-check I'll use a tree-based, recursive feature-elimination version.</p>
<div class="highlight">
<pre><span></span>trees = ExtraTreesClassifier(n_estimators=10)
eliminator = RFECV(estimator=trees, cv=StratifiedKFold(10), scoring="roc_auc")
eliminator.fit(x_train, y_train)
x_train_trees = eliminator.transform(x_train)
x_test_trees = eliminator.transform(x_test)
</pre></div>
<div class="highlight">
<pre><span></span>print(x_train_trees.shape)
print(eliminator.ranking_)
</pre></div>
<p>This eliminated many more columns than the Logistic Regression version did.</p>
<p><b>warning</b> this seem to change every time you run it - the randomness changes it. Only the elimination of the first column seems to do as well as not running it at all.</p>
</div>
</div>
<div class="outline-2" id="outline-container-org19ffe46">
<h2 id="org19ffe46">Fit and Display</h2>
<div class="outline-text-2" id="text-org19ffe46">
<p>This is a convenience function so I can fit and display the scores for the models.</p>
<div class="highlight">
<pre><span></span>def fit_and_display(model, identifier):
    """Fit and display the scores

    Args:
     model: The instantiated model to fit
     identifier (str): something to output at the beginning
    """
    print(identifier)
    print("=" * len(identifier))
    model.fit(x_train, y_train)
    print("\nX-train")
    print("Score: {:.2f}".format(model.score(x_test, y_test)))
    print("\nX-Train Positive")
    model.fit(x_train_positive, y_train)
    print("Score: {:.2f}".format(model.score(x_test_positive, y_test)))
    print("\nX-Train Trees")
    model.fit(x_train_trees, y_train)
    print("Score: {:.2f}".format(model.score(x_test_trees, y_test)))
    print("\nBest Training Score: {}".format(search.best_score_))
    return
</pre></div>
</div>
</div>
<div class="outline-2" id="outline-container-orgd6ee56a">
<h2 id="orgd6ee56a">Logistic Regression</h2>
<div class="outline-text-2" id="text-orgd6ee56a"></div>
<div class="outline-3" id="outline-container-org200e4fd">
<h3 id="org200e4fd">L1 Penalty</h3>
<div class="outline-text-3" id="text-org200e4fd">
<div class="highlight">
<pre><span></span>model = LogisticRegressionCV(penalty="l1", scoring="roc_auc", solver="liblinear")
fit_and_display(model, "Logistic Regression L1")
</pre></div>
<p>I've already run the Logistic Regression using a 'l1' but I'll try it again with 'l2' to see if it improved.</p>
<div class="highlight">
<pre><span></span>model = LogisticRegressionCV(scoring="roc_auc", solver="liblinear")
fit_and_display(model, "LogisticRegression")
</pre></div>
<p>L1 seems to do better than L1 overall, although it doesn't do as well with the recursively data form some reason.</p>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org78c87a6">
<h2 id="org78c87a6">Random Forests</h2>
<div class="outline-text-2" id="text-org78c87a6">
<p>I'll try a <a href="http://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html">Random Forest</a> classifier next.</p>
<div class="highlight">
<pre><span></span>parameter_grid = dict(n_estimators=range(10, 100, 10))
search = GridSearchCV(RandomForestClassifier(), parameter_grid,
                      cv=StratifiedKFold(10), scoring="roc_auc")
fit_and_display(search, "Random Forest")
</pre></div>
<p>This seems to have done much better than the logistic regression did. My logistic-regression feature reduction doesn't seem to help.</p>
<div class="highlight">
<pre><span></span>class RandomForest(object):
    """trains a random forest on the x-test-trees set

    Args:
     start (int): first n-estimators value to use
     stop (int): last n-estimators value (minus step)
     step (int): amount to increment estimators
     folds (int): Cross-validation-folds to usen

    Returns:
     GridSearchCV: grid-search with the best estimator
    """

    def __init__(self, start, stop, step, folds=10):
        self.start = start
        self.stop = stop
        self.step = step
        self.folds = folds
        self._search = None
        self._parameter_grid = None
        return

    @property
    def parameter_grid(self):
        """dict of the number of estimators to use"""
        if self._parameter_grid is None:
            self._parameter_grid = dict(n_estimators=list(range(self.start,
                                                                self.stop,
                                                                self.step)))
        return self._parameter_grid

    @property
    def search(self):
        """grid-search cv object"""
        if self._search is None:
            self._search = GridSearchCV(RandomForestClassifier(),
                                        self.parameter_grid,
                                        cv=StratifiedKFold(self.folds),
                                        scoring="roc_auc")
        return self._search    

    def fit(self):
        """fits the model to the tree-based reduced-feature data"""
        self.search.fit(x_train_trees, y_train)
        print(self.search.score(x_test_trees, y_test))
        print(self.search.best_estimator_.feature_importances_)
        print(self.search.best_params_)
        return

    def plot(self):
        """Plots estimators vs AUC scores"""
        figure = pyplot.figure()
        axe = figure.gca()
        axe.plot(self.parameter_grid["n_estimators"],
                 self.search.cv_results_["mean_test_score"])
        axe.set_title("Estimator Count vs AUC")
        axe.set_xlabel("Number of estimators (trees)")
        axe.set_ylabel("Mean AUC Score")
        return
</pre></div>
<div class="highlight">
<pre><span></span>search = RandomForest(10, 100, 10)
search.fit()
</pre></div>
<p>Not a lot of variance in the importance of the features.</p>
<div class="highlight">
<pre><span></span>search.plot()
</pre></div>
<p>Would things get better with more trees?</p>
<div class="highlight">
<pre><span></span>search = RandomForest(150, 250, 10)
search.fit()
</pre></div>
<div class="highlight">
<pre><span></span>search.plot()
</pre></div>
<p>In this case the test-score was better, although the training scores don't look much better. I guess it's the randomness coming into play again. I'll try a long run instead.</p>
<div class="highlight">
<pre><span></span>search = RandomForest(10, 500, 10)
search.fit()
</pre></div>
<div class="highlight">
<pre><span></span>search.plot()
</pre></div>
<p>The test-score for the best estimator is actually a little worse than it was for the previous case, although it's qute a small difference.</p>
</div>
</div>
<div class="outline-2" id="outline-container-orgb2e286f">
<h2 id="orgb2e286f">K Nearest Neighbors</h2>
<div class="outline-text-2" id="text-orgb2e286f">
<div class="highlight">
<pre><span></span>parameters = dict(n_neighbors=range(10, 20),
                  weights=["uniform", "distance"],
                  p=[1, 2],
                  leaf_size=range(10, 50, 10))

search = GridSearchCV(KNeighborsClassifier(), parameters, scoring="roc_auc")
search.fit(x_train_trees, y_train)
</pre></div>
<div class="highlight">
<pre><span></span>print(search.score(x_test_trees, y_test))
print(search.best_params_)
</pre></div>
<p>This doesn't seem to do so well, although I'm not as experienced at using it so I might be using bad parameters.</p>
</div>
</div>
<div class="outline-2" id="outline-container-orgf78b53b">
<h2 id="orgf78b53b">Support Vector Classifier (SVC)</h2>
<div class="outline-text-2" id="text-orgf78b53b">
<div class="highlight">
<pre><span></span>parameters = dict(C=numpy.arange(.1, 1, 0.1), gamma=range(1, 10, 1),
                  kernel=["linear", 'rbf', 'sigmoid'])
search = GridSearchCV(SVC(class_weight='balanced'), parameters, scoring='roc_auc')
fit_and_display(search, "SVC")
</pre></div>
<div class="highlight">
<pre><span></span>print(search.score(x_test_trees, y_test))
print(search.best_params_)
</pre></div>
<p>Now that the data is scaled, the svc does much better, alhough still not as well as the random forest.</p>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="posts/networks/future-e-mail/">Future E-Mail</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="posts/networks/future-e-mail/" rel="bookmark"><time class="published dt-published" datetime="2019-04-13T11:52:40-07:00" itemprop="datePublished" title="2019-04-13 11:52">2019-04-13 11:52</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="posts/networks/future-e-mail/#org0bd1730">Tangle</a></li>
<li><a href="posts/networks/future-e-mail/#org81fb40a">Imports</a></li>
<li><a href="posts/networks/future-e-mail/#org3804397">Constants</a></li>
<li><a href="posts/networks/future-e-mail/#org2a792c2">The Email-Graph</a></li>
<li><a href="posts/networks/future-e-mail/#org8ea422d">The Data</a>
<ul>
<li><a href="posts/networks/future-e-mail/#org4dbe7da">The Given Data</a></li>
</ul>
</li>
<li><a href="posts/networks/future-e-mail/#org35cf448">Adding networkx features</a>
<ul>
<li><a href="posts/networks/future-e-mail/#org611230b">Add Networkx Data</a></li>
<li><a href="posts/networks/future-e-mail/#org3d753a0">Adding A Resource Allocation Index</a></li>
<li><a href="posts/networks/future-e-mail/#org2dee0ca">Adding the Jaccard Coefficient</a></li>
<li><a href="posts/networks/future-e-mail/#org56bc368">Adamic Adar</a></li>
<li><a href="posts/networks/future-e-mail/#org7d6a96f">Preferential Attachment</a></li>
<li><a href="posts/networks/future-e-mail/#org07c8429">Community-Based Link Prediction</a></li>
<li><a href="posts/networks/future-e-mail/#org0495260">Saving the Data</a></li>
</ul>
</li>
<li><a href="posts/networks/future-e-mail/#orgc9bc8f5">Setup the Training and Testing Data</a>
<ul>
<li><a href="posts/networks/future-e-mail/#orgfead0d3">Separating the Edges Without 'Future Connection' Values</a></li>
<li><a href="posts/networks/future-e-mail/#orgaa6c514">Separate the Target and Training Sets</a></li>
<li><a href="posts/networks/future-e-mail/#org9f0a896">Setting Up the Testing and Training Sets</a></li>
<li><a href="posts/networks/future-e-mail/#org906bc5a">Scaling the Data</a></li>
<li><a href="posts/networks/future-e-mail/#org1fc0434">Feature Selection</a></li>
</ul>
</li>
<li><a href="posts/networks/future-e-mail/#org108e511">Fitting the Models</a>
<ul>
<li><a href="posts/networks/future-e-mail/#org98c5a48">Persistent Storage</a></li>
<li><a href="posts/networks/future-e-mail/#org1d95d09">Logistic Regression</a></li>
<li><a href="posts/networks/future-e-mail/#orgb165931">Fit Grid Search</a></li>
<li><a href="posts/networks/future-e-mail/#org0f1b6c4">Random Forests</a></li>
<li><a href="posts/networks/future-e-mail/#orgcf84a9f">Extra Trees</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>This will select a model to predict whether an edge in the email-network that currently doesn't have an edge will have one in the future.</p>
<div class="outline-2" id="outline-container-org0bd1730">
<h2 id="org0bd1730">Tangle</h2>
<div class="outline-text-2" id="text-org0bd1730">
<div class="highlight">
<pre><span></span><span class="o">&lt;&lt;</span><span class="n">imports</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">futures</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">data</span><span class="o">-</span><span class="n">names</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">files</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">training</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">load</span><span class="o">-</span><span class="n">graph</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">load</span><span class="o">-</span><span class="n">future</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">add</span><span class="o">-</span><span class="n">networkx</span><span class="o">-</span><span class="n">data</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">future</span><span class="o">-</span><span class="n">connections</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">jaccard</span><span class="o">-</span><span class="n">coefficient</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">adamic</span><span class="o">-</span><span class="n">adar</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">preferential</span><span class="o">-</span><span class="n">attachment</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">save</span><span class="o">-</span><span class="n">future</span><span class="o">-</span><span class="n">connections</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">split</span><span class="o">-</span><span class="n">future</span><span class="o">-</span><span class="n">connections</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">train</span><span class="o">-</span><span class="n">test</span><span class="o">-</span><span class="n">predict</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">train</span><span class="o">-</span><span class="n">test</span><span class="o">-</span><span class="n">split</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">scaled</span><span class="o">-</span><span class="n">data</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">pickle</span><span class="o">-</span><span class="n">it</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">unpickle</span><span class="o">-</span><span class="n">it</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">lr</span><span class="o">-</span><span class="n">rfs</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">trees</span><span class="o">-</span><span class="n">rfs</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">lr</span><span class="o">-</span><span class="n">sfm</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">trees</span><span class="o">-</span><span class="n">fsm</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">scores</span><span class="o">-</span><span class="n">identifiers</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">fit</span><span class="o">-</span><span class="ow">and</span><span class="o">-</span><span class="k">print</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">data</span><span class="o">-</span><span class="n">sets</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">key</span><span class="o">-</span><span class="n">by</span><span class="o">-</span><span class="n">value</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">fit</span><span class="o">-</span><span class="ow">and</span><span class="o">-</span><span class="k">print</span><span class="o">-</span><span class="nb">all</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">logistic</span><span class="o">-</span><span class="n">model</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">fit</span><span class="o">-</span><span class="n">grid</span><span class="o">-</span><span class="n">search</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">fit</span><span class="o">-</span><span class="n">grid</span><span class="o">-</span><span class="n">searches</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">random</span><span class="o">-</span><span class="n">forests</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">extra</span><span class="o">-</span><span class="n">trees</span><span class="o">&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="outline-2" id="outline-container-org81fb40a">
<h2 id="org81fb40a">Imports</h2>
<div class="outline-text-2" id="text-org81fb40a">
<div class="highlight">
<pre><span></span># python standard library
import os
import pickle

# pypi
import networkx
import pandas
import seaborn

from numba import jit

from sklearn.ensemble import (
    ExtraTreesClassifier,
    RandomForestClassifier,
    )
from sklearn.feature_selection import (
    RFECV,
    SelectFromModel,
    )
from sklearn.linear_model import LogisticRegressionCV
from sklearn.model_selection import (
    train_test_split,
    GridSearchCV,
    StratifiedKFold,
    )
from sklearn.preprocessing import StandardScaler
</pre></div>
<div class="highlight">
<pre><span></span>% matplotlib inline
seaborn.set_style("whitegrid")
</pre></div>
</div>
</div>
<div class="outline-2" id="outline-container-org3804397">
<h2 id="org3804397">Constants</h2>
<div class="outline-text-2" id="text-org3804397">
<div class="highlight">
<pre><span></span>class Futures(object):
    target = "Future Connection"
    data_file = "Future_Connections.csv"
    graph_file = "email_prediction.txt"
    networkx_data_index = 2
    folds = 10
</pre></div>
<div class="highlight">
<pre><span></span>class DataNames(object):
    resource_allocation = 'resource_allocation'
    jaccard = 'jaccard_coefficient'
    adamic = "adamic_adar"
    preferential = "preferential_attachment"
</pre></div>
<div class="highlight">
<pre><span></span>class Files(object):
    """File-names for data persistence"""
    future_training_data = 'future_training_data.csv'
    future_selection_outcomes = 'future_selection_outcomes.pkl'
    future_model_selection = "future_model_cvs.pkl"
</pre></div>
<div class="highlight">
<pre><span></span>class Training(object):
    """data-pickles"""
    x_train_lr_rfs = "x_train_lr_rfs.pkl"
    x_test_lr_rfs = "x_test_lr_rfs.pkl"
    x_train_trees_rfs = "x_train_trees_rfs.pkl"
    x_test_trees_rfs = "x_test_trees_rfs.pkl"
    x_train_lr_sfm = "x_train_lr_sfm.pkl"
    x_test_lr_sfm = "x_test_lr_sfm.pkl"
    x_train_trees_sfm = "x_train_trees_sfm.pkl"
    x_test_trees_sfm = "x_test_trees_sfm.pkl"
</pre></div>
</div>
</div>
<div class="outline-2" id="outline-container-org2a792c2">
<h2 id="org2a792c2">The Email-Graph</h2>
<div class="outline-text-2" id="text-org2a792c2">
<p>To get the features for the models we'll need to use the email-graph.</p>
<div class="highlight">
<pre><span></span>email = networkx.read_gpickle(Futures.graph_file)
</pre></div>
</div>
</div>
<div class="outline-2" id="outline-container-org8ea422d">
<h2 id="org8ea422d">The Data</h2>
<div class="outline-text-2" id="text-org8ea422d"></div>
<div class="outline-3" id="outline-container-org4dbe7da">
<h3 id="org4dbe7da">The Given Data</h3>
<div class="outline-text-3" id="text-org4dbe7da">
<p>We're given a csv file with the training and prediction data in it ('Future<sub>Connections.csv</sub>').</p>
<div class="highlight">
<pre><span></span>head Future_Connections.csv
<span class="nb">echo</span>
</pre></div>
<p>Org-mode converted it to a table, but it's actually a CSV. The first line of data looks like this.</p>
<pre class="example">
"(6, 840)",0.0
</pre>
<div class="highlight">
<pre><span></span>future_connections_pre_loaded = os.path.isfile(Files.future_training_data)
if future_connections_pre_loaded:
    future_connections = pandas.read_csv(Files.future_training_data,
                                         index_col=0)
else:
    future_connections = pandas.read_csv(Futures.data_file,
                                         index_col=0,
                                         converters={0: eval})
</pre></div>
<p>So, we're loading the node-pairs (edges) as the index of the data-frame and explicitly telling pandas that the Future Connection values should be converted , which I don't think is necessary, but this came with the problem statement so I'll just leave it in in case there's some side-effect I'm not aware of.</p>
<div class="highlight">
<pre><span></span>print(future_connections[Futures.target].value_counts())
</pre></div>
<p>This is a fairly big (and lopsided) data-set.</p>
<div class="highlight">
<pre><span></span>seaborn.countplot(x=Futures.target, data=future_connections)
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org35cf448">
<h2 id="org35cf448">Adding networkx features</h2>
<div class="outline-text-2" id="text-org35cf448">
<p>To create features to train the model and make predictions, I'm going to use the networkx <a href="https://networkx.github.io/documentation/networkx-1.10/reference/algorithms.link_prediction.html">link prediction</a> algorithms.</p>
</div>
<div class="outline-3" id="outline-container-org611230b">
<h3 id="org611230b">Add Networkx Data</h3>
<div class="outline-text-3" id="text-org611230b">
<p>This is a function to get networkx data and add it to the data-frame. It won't work for the community-based algorithms.</p>
<div class="highlight">
<pre><span></span>def add_networkx_data(adder, name, graph=email, frame=future_connections):
    """Adds networkx data to the frame

    The networkx link-prediction functions return generators of triples:
     (first-node, second-node, value)

    This will use the index of the frame that's passed in as the source of 
    node-pairs for the networkx function (called `ebunch` in the networkx
    documentation) and the add only the value we want back to the frame

    Args:
     adder: networkx function to call to get the new data
     name: column-name to add to the frame
     graph: networkx graph to pass to the function
     frame (pandas.DataFrame): frame with node-pairs as index to add data to
    """
    frame[name] = [output[Futures.networkx_data_index]
                   for output in adder(graph, frame.index)]
    return frame
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org3d753a0">
<h3 id="org3d753a0">Adding A Resource Allocation Index</h3>
<div class="outline-text-3" id="text-org3d753a0">
<div class="highlight">
<pre><span></span>if not future_connections_pre_loaded:
    add_networkx_data(networkx.resource_allocation_index,
                      DataNames.resource_allocation)
</pre></div>
<div class="highlight">
<pre><span></span>print(future_connections.head(1))
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org2dee0ca">
<h3 id="org2dee0ca">Adding the Jaccard Coefficient</h3>
<div class="outline-text-3" id="text-org2dee0ca">
<div class="highlight">
<pre><span></span>if not future_connections_pre_loaded:
    add_networkx_data(networkx.jaccard_coefficient, DataNames.jaccard)
</pre></div>
<div class="highlight">
<pre><span></span>print(future_connections.head(1))
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org56bc368">
<h3 id="org56bc368">Adamic Adar</h3>
<div class="outline-text-3" id="text-org56bc368">
<div class="highlight">
<pre><span></span>if not future_connections_pre_loaded:
    add_networkx_data(networkx.adamic_adar_index, DataNames.adamic)
</pre></div>
<div class="highlight">
<pre><span></span>print(future_connections.head(1))
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org7d6a96f">
<h3 id="org7d6a96f">Preferential Attachment</h3>
<div class="outline-text-3" id="text-org7d6a96f">
<div class="highlight">
<pre><span></span>if not future_connections_pre_loaded:
    add_networkx_data(networkx.preferential_attachment, DataNames.preferential)
</pre></div>
<div class="highlight">
<pre><span></span>print(future_connections.head(1))
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org07c8429">
<h3 id="org07c8429">Community-Based Link Prediction</h3>
<div class="outline-text-3" id="text-org07c8429">
<p>This requires identifying 'communities' first, so I'll defer it for now.</p>
<div class="highlight">
<pre><span></span>#add_networkx_data(networkx.cn_soundarajan_hopcroft, DataNames.common_neighbors)
</pre></div>
<p>These three all require communities for them to work (so I'm skipping them):</p>
<ul class="org-ul">
<li>cn<sub>soundarajan</sub><sub>hopcroft</sub></li>
<li>ra<sub>index</sub><sub>soundarajan</sub><sub>hopcroft</sub></li>
<li>within<sub>inter</sub><sub>cluster</sub></li>
</ul>
</div>
</div>
<div class="outline-3" id="outline-container-org0495260">
<h3 id="org0495260">Saving the Data</h3>
<div class="outline-text-3" id="text-org0495260">
<div class="highlight">
<pre><span></span>future_connections.to_csv(Files.future_training_data)
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-orgc9bc8f5">
<h2 id="orgc9bc8f5">Setup the Training and Testing Data</h2>
<div class="outline-text-2" id="text-orgc9bc8f5"></div>
<div class="outline-3" id="outline-container-orgfead0d3">
<h3 id="orgfead0d3">Separating the Edges Without 'Future Connection' Values</h3>
<div class="outline-text-3" id="text-orgfead0d3">
<p>We are going to train on the values in the data with predictions and then make predictions for those that don't. For model selection we don't need the set missing predictions, but I'll separate it out anyway to be complete.</p>
<div class="highlight">
<pre><span></span>prediction_set = future_connections[future_connections[Futures.target].isnull()]
training_set = future_connections[future_connections[Futures.target].notnull()]
</pre></div>
<div class="highlight">
<pre><span></span>print(prediction_set.shape)
print(training_set.shape)
assert len(prediction_set) + len(training_set) == len(future_connections)
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-orgaa6c514">
<h3 id="orgaa6c514">Separate the Target and Training Sets</h3>
<div class="outline-text-3" id="text-orgaa6c514">
<div class="highlight">
<pre><span></span>non_target = [column for column in future_connections.columns
              if column != Futures.target]
training = training_set[non_target]
testing = training_set[Futures.target]
predictions = prediction_set[non_target]
</pre></div>
<div class="highlight">
<pre><span></span>assert all(training.columns == predictions.columns)
assert len(training) == len(testing)
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org9f0a896">
<h3 id="org9f0a896">Setting Up the Testing and Training Sets</h3>
<div class="outline-text-3" id="text-org9f0a896">
<div class="highlight">
<pre><span></span>x_train, x_test, y_train, y_test = train_test_split(training, testing, stratify=testing)
</pre></div>
<div class="highlight">
<pre><span></span>print(x_train.shape)
print(x_test.shape)
</pre></div>
<div class="highlight">
<pre><span></span>seaborn.countplot(y_train)
</pre></div>
<div class="highlight">
<pre><span></span>seaborn.countplot(y_test)
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org906bc5a">
<h3 id="org906bc5a">Scaling the Data</h3>
<div class="outline-text-3" id="text-org906bc5a">
<p>To enable the use of linear models I'm going to scale the data so the mean is 0 and the variance is 1.</p>
<div class="highlight">
<pre><span></span>scaler = StandardScaler()
x_train = scaler.fit_transform(x_train)
x_test = scaler.transform(x_test)

x_train = pandas.DataFrame(x_train, columns=training.columns)
x_test = pandas.DataFrame(x_test, columns=training.columns)
</pre></div>
<div class="highlight">
<pre><span></span>print(x_train.describe())
print(x_test.describe())
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org1fc0434">
<h3 id="org1fc0434">Feature Selection</h3>
<div class="outline-text-3" id="text-org1fc0434">
<p>To reduce the dimensionality I'm going to use recursive feature selection and model-based selection.</p>
<div class="highlight">
<pre><span></span>def pickle_it(thing, name):
    """saves the thing as a pickle"""
    with open(name, "wb") as writer:
        pickle.dump(thing, writer)
</pre></div>
<div class="highlight">
<pre><span></span>def unpickle_it(name):
    """loads the object from the file-name

    Args:
     name (str): name of binary pickle file

    Returns:
     obj: unpickled object
    """
    with open(name, 'rb') as reader:
        thing = pickle.load(reader)
    return thing
</pre></div>
</div>
<div class="outline-4" id="outline-container-org8b140d9">
<h4 id="org8b140d9">RFECV with Logistic Regression</h4>
<div class="outline-text-4" id="text-org8b140d9">
<div class="highlight">
<pre><span></span>if os.path.isfile(Training.x_train_lr_rfs):
    x_train_lr_rfs = unpickle_it(Training.x_train_lr_rfs)
    x_test_lr_rfs = unpickle_it(Training.x_test_lr_rfs)
else:
    estimator = LogisticRegressionCV(n_jobs=-1)
    selector = RFECV(estimator, scoring='roc_auc',
                     n_jobs=-1,
                     cv=StratifiedKFold(Futures.folds))
    x_train_lr_rfs = selector.fit_transform(x_train, y_train)
    x_test_lr_rfs = selector.transform(x_test)
    pickle_it(x_train_lr_rfs, Training.x_train_lr_rfs)
    pickle_it(x_test_lr_rfs, Training.x_test_lr_rfs)
    print(selector.ranking_)
</pre></div>
<p>It looks like it only discarded preferential attachment.</p>
</div>
</div>
<div class="outline-4" id="outline-container-org26492c4">
<h4 id="org26492c4">RFECV with Extra Trees</h4>
<div class="outline-text-4" id="text-org26492c4">
<div class="highlight">
<pre><span></span>if os.path.isfile(Training.x_train_trees_rfs):
    x_train_trees_rfs = unpickle_it(Training.x_train_trees_rfs)
    x_test_trees_rfs = unpickle_it(Training.x_test_trees_rfs)
else:
    estimator = ExtraTreesClassifier()
    selector = RFECV(estimator, scoring='roc_auc', n_jobs=-1, cv=StratifiedKFold(Futures.folds))
    x_train_trees_rfs = selector.fit_transform(x_train, y_train)
    x_test_trees_rfs = selector.transform(x_test)
    pickle_it(x_train_trees_rfs, Training.x_train_trees_rfs)
    pickle_it(x_test_trees_rfs, Training.x_test_trees_rfs)
    print(selector.ranking_)
</pre></div>
<p>Strangely, the Extra Trees Classifier didn't remove any columns…</p>
</div>
</div>
<div class="outline-4" id="outline-container-org1e35886">
<h4 id="org1e35886">Select Model Logistic Regression</h4>
<div class="outline-text-4" id="text-org1e35886">
<div class="highlight">
<pre><span></span>if os.path.isfile(Training.x_train_lr_sfm):
    x_train_lr_sfm = unpickle_it(Training.x_train_lr_sfm)
    x_test_lr_sfm = unpickle_it(Training.x_test_lr_sfm)
else:
    estimator = LogisticRegressionCV(
        n_jobs=-1, scoring='roc_auc',
        cv=StratifiedKFold(Futures.folds)).fit(x_train,
                                               y_train)
    selector = SelectFromModel(estimator, prefit=True)
    x_train_lr_sfm = selector.transform(x_train)
    x_test_lr_sfm = selector.transform(x_test)
    pickle_it(x_train_lr_sfm, Training.x_train_lr_sfm)
    pickle_it(x_test_lr_sfm, Training.x_test_lr_sfm)
    print(estimator.coef_)
</pre></div>
<div class="highlight">
<pre><span></span>print(x_train_lr_sfm.shape)
</pre></div>
<p>This was more aggressive, cutting out half the features. It looks like it kept <b>Jaccard Coefficient</b> and <b>Adamic Adar</b> and got rid of <b>Resource Allocation</b> and <b>Preferential Attachment</b>.</p>
</div>
</div>
<div class="outline-4" id="outline-container-org0af64f3">
<h4 id="org0af64f3">Select Model Extra Trees</h4>
<div class="outline-text-4" id="text-org0af64f3">
<div class="highlight">
<pre><span></span>if os.path.isfile(Training.x_train_trees_sfm):
    x_train_trees_sfm = unpickle_it(Training.x_train_trees_sfm)
    x_test_trees_sfm = unpickle_it(Training.x_test_trees_sfm)
else:
    estimator = ExtraTreesClassifier()
    estimator.fit(x_train, y_train)
    selector = SelectFromModel(estimator, prefit=True)
    x_train_trees_sfm = selector.transform(x_train)
    x_test_trees_sfm = selector.transform(x_test)
    pickle_it(x_train_trees_sfm, Training.x_train_trees_sfm)
    pickle_it(x_test_trees_sfm, Training.x_test_trees_sfm)
    print(estimator.feature_importances_)
</pre></div>
<div class="highlight">
<pre><span></span>print(x_train_trees_sfm.shape)
</pre></div>
<p>This is sometimes more aggressive, keeping only the <b>Adamic Adar</b> feature… But maybe that's all you need, we'll see. Then again, other times it isn't as aggressive, only trimming two columns, and this tiem it only trimmed one…</p>
</div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org108e511">
<h2 id="org108e511">Fitting the Models</h2>
<div class="outline-text-2" id="text-org108e511"></div>
<div class="outline-3" id="outline-container-org98c5a48">
<h3 id="org98c5a48">Persistent Storage</h3>
<div class="outline-text-3" id="text-org98c5a48">
<p>The outcomes will be stored in a dictionary called <code>scores</code> with descriptions of the best model and feature-selection mapped to their testing-score.</p>
<div class="highlight">
<pre><span></span>if os.path.isfile(Files.future_model_selection):
    with open(Files.future_model_selection, 'rb') as pkl:
        scores = pickle.load(pkl)
else:
    scores = {}
</pre></div>
<div class="highlight">
<pre><span></span>def fit_and_print(estimator, x_train, x_test):
    """fits the estimator to the data

    Args:
     estimator: model to fit
     x_train: scaled data to fit model to
     x_test: data to test the model with

    Returns:
     tuple: model fit to the data, test score
    """
    model = estimator.fit(x_train, y_train)
    test_score = model.score(x_test, y_test)
    print("Mean Cross-Validation Score: {:.2f}".format(model.scores_[1].mean()))
    print("Testing Score: {:.2f}".format(test_score))
    return model, test_score
</pre></div>
<div class="highlight">
<pre><span></span>data_sets = {("extra trees", 'select from model') : (x_train_trees_sfm, x_test_trees_sfm),
             ("extra trees", 'recursive feature selection') : (x_train_trees_rfs, x_test_trees_rfs),
             ('logistic regression', "recursive feature selection") : (x_train_lr_rfs, x_test_lr_rfs),
             ('logistic regression', "select from model") : (x_train_lr_sfm, x_test_lr_sfm)}
</pre></div>
<div class="highlight">
<pre><span></span>def key_by_value(source, search_value):
    """Find the key in a dict that matches a value

    Args:
     source (dict): dictionary with value to search for
     search_value: value to search for

    Returns:
     object: key in source that matched value
    """
    for key, value in source.items():
        if value == search_value:
            return key
    return
</pre></div>
<div class="highlight">
<pre><span></span>def fit_and_print_all(model, model_name):
    """Fits the model against all data instances

    Args:
     model: model to fit to the data sets
     model_name: identifier for the outcomes
    """
    for data_set, x in data_sets.items():
        selector, method = data_set
        train, test = x
        key = ','.join([model_name, selector, method])
        print("Training Shape: {}".format(train.shape))
        if key not in scores:
            print(key)
            fitted, score = fit_and_print(model, train, test)
            scores[key] = score
        else:
            score = scores[key]
            print("{}: {:.3f}".format(key, score))
        print()

    best_score = max(scores.values())
    best_key = key_by_value(scores, best_score)
    print("Best Model So Far: {}, Score={:.2f}".format(
        best_key,
        best_score))
    with open(Files.future_model_selection, 'wb') as writer:
        pickle.dump(scores, writer)
    return
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org1d95d09">
<h3 id="org1d95d09">Logistic Regression</h3>
<div class="outline-text-3" id="text-org1d95d09">
<div class="highlight">
<pre><span></span>logistic_model = LogisticRegressionCV(n_jobs=-1, scoring="roc_auc",
                                      solver='liblinear',
                                      cv=StratifiedKFold(Futures.folds))
fit_and_print_all(logistic_model, "Logistic Regression")
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-orgb165931">
<h3 id="orgb165931">Fit Grid Search</h3>
<div class="outline-text-3" id="text-orgb165931">
<p>Since the Logistic Regression had its own cross-validation I didn't use a grid search, but for the forests I'll use one to figure out the best number of estimators. I'll have to look into what the other parameters do to figure out whether they're going to be useful.</p>
<div class="highlight">
<pre><span></span>def fit_grid_search(estimator, parameters, x_train, x_test):
    """Fits the estimator using grid search

    Args:
     estimator: Model to fit
     parameters (dict): hyper-parameters for the grid search
     x_train (array): the training data input
     x_test (array): data to evaluate the best model with

    Returns: 
     tuple: Best Model, best model score
    """
    search = GridSearchCV(estimator, parameters, n_jobs=-1, scoring='roc_auc',
                          cv=StratifiedKFold(Futures.folds))
    search.fit(x_train, y_train)
    best_model = search.best_estimator_
    test_score = best_model.score(x_test, y_test)
    print("Mean of Mean Cross-Validation Scores: {:.2f}".format(
        search.cv_results_["mean_train_score"].mean()))
    print("Mean of Cross-Validation Score STDs: {:.2f}".format(
        search.cv_results_["std_train_score"].mean()))
    print("Testing Score: {:.2f}".format(test_score))
    return best_model, test_score
</pre></div>
<div class="highlight">
<pre><span></span>def fit_grid_searches(estimator, parameters, name, data_sets=data_sets):
    """Fits the estimator against all the data-sets

    Args:
     estimator: instance of model to test
     parameters: dict of grid-search parameters
     name: identifier for the model
    """
    for data_set, x in data_sets.items():
        selector, method = data_set
        train, test = x
        key = ",".join([name, selector, method])
        if key not in scores:
            print(key)
            fitted, score = fit_grid_search(estimator, parameters, train, test)
            scores[key] = score
        else:
            score = scores[key]
            print("{}: {:.2f}".format(key, score))
        print()
    best = max(scores.values())
    best_key = key_by_value(scores, best)
    print("Best Model So Far: {}, Score={:.2f}".format(best_key, best))
    with open(Files.future_model_selection, 'wb') as writer:
        pickle.dump(scores, writer)
    return
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org0f1b6c4">
<h3 id="org0f1b6c4">Random Forests</h3>
<div class="outline-text-3" id="text-org0f1b6c4">
<div class="highlight">
<pre><span></span>parameters = dict(n_estimators = list(range(10, 200, 10)))
forest = RandomForestClassifier()
fit_grid_searches(forest, parameters, "Random Forest")
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-orgcf84a9f">
<h3 id="orgcf84a9f">Extra Trees</h3>
<div class="outline-text-3" id="text-orgcf84a9f">
<div class="highlight">
<pre><span></span>scores = {k:v for k,v in scores.items() if not k.startswith('Extra Trees,extra trees')}
parameters = dict(n_estimators = list(range(10, 200, 10)))
trees = ExtraTreesClassifier()
fit_grid_searches(trees, parameters, "Extra Trees")
</pre></div>
</div>
</div>
</div>
</div>
</article>
<ul class="pager postindexpager clearfix">
<li class="next"><a href="index-3.html" rel="next">Older posts</a></li>
</ul>
<!--End of body content-->
<footer id="footer">Contents © 2019 <a href="mailto:necromuralist@protonmail.com">Cloistered Monkey</a> - Powered by <a href="https://getnikola.com" rel="nofollow">Nikola</a></footer>
<script src="assets/js/all-nocdn.js"></script>
<script>

    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
</script> </div>
</div>
</div>
</article>
</div>
</div>
</div>
</body>
</html>
